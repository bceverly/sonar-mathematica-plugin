package org.sonar.plugins.mathematica.coverage;

import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.sonar.api.batch.fs.FileSystem;
import org.sonar.api.batch.fs.InputFile;
import org.sonar.api.batch.sensor.Sensor;
import org.sonar.api.batch.sensor.SensorContext;
import org.sonar.api.batch.sensor.SensorDescriptor;
import org.sonar.api.batch.sensor.coverage.NewCoverage;
import org.sonar.api.config.Configuration;
import org.sonar.plugins.mathematica.MathematicaLanguage;

/**
 * Sensor that reads Mathematica coverage data from JSON files and reports it to SonarQube.
 *
 * This sensor reads coverage data generated by the CoverageUtils.wl Mathematica package
 * and uploads it to SonarQube for display in the coverage reports.
 *
 * Coverage file format: JSON array of file coverage objects
 * Each object contains:
 * - FileName: Name of the source file
 * - FullPath: Absolute path to the source file
 * - TotalLines: Total number of lines in the file
 * - CodeLines: Number of lines with code
 * - CoveredLines: Number of lines covered by tests
 * - Coverage: Coverage percentage (0.0 to 1.0)
 * - LineCoverage: Array of line-by-line coverage data
 *   - Line: Line number (1-based)
 *   - IsCode: Whether the line contains code
 *   - Hits: Number of times the line was executed
 *
 * Configuration:
 * - sonar.mathematica.coverage.reportPath: Path to coverage.json file (default: coverage/coverage.json)
 *
 * @author Bryan C. Everly
 */
public class MathematicaCoverageSensor implements Sensor {

    private static final Logger LOG = LoggerFactory.getLogger(MathematicaCoverageSensor.class);

    public static final String REPORT_PATH_KEY = "sonar.mathematica.coverage.reportPath";
    public static final String DEFAULT_REPORT_PATH = "coverage/coverage.json";

    @Override
    public void describe(SensorDescriptor descriptor) {
        descriptor
            .name("Mathematica Coverage Sensor")
            .onlyOnLanguage(MathematicaLanguage.KEY);
    }

    @Override
    public void execute(SensorContext context) {
        Configuration config = context.config();
        String reportPath = config.get(REPORT_PATH_KEY).orElse(DEFAULT_REPORT_PATH);

        FileSystem fs = context.fileSystem();
        File coverageFile = fs.resolvePath(reportPath);

        if (!coverageFile.exists()) {
            LOG.info("Coverage report not found at: {}. Skipping coverage import.", coverageFile.getAbsolutePath());
            return;
        }

        LOG.info("Reading coverage report from: {}", coverageFile.getAbsolutePath());

        try {
            importCoverageData(context, coverageFile, fs);
        } catch (Exception e) {
            LOG.error("Error importing coverage data from {}: {}", coverageFile, e.getMessage(), e);
        }
    }

    /**
     * Import coverage data from the JSON file and report it to SonarQube.
     */
    private void importCoverageData(SensorContext context, File coverageFile, FileSystem fs) throws IOException {
        try (FileReader reader = new FileReader(coverageFile)) {
            JsonArray coverageArray = JsonParser.parseReader(reader).getAsJsonArray();

            int filesProcessed = 0;
            int filesSkipped = 0;

            for (JsonElement element : coverageArray) {
                JsonObject fileData = element.getAsJsonObject();

                String fullPath = fileData.get("FullPath").getAsString();
                String fileName = fileData.get("FileName").getAsString();

                // Find the InputFile in the SonarQube file system
                InputFile inputFile = findInputFile(fs, fullPath, fileName);

                if (inputFile == null) {
                    LOG.debug("Source file not found in project: {}. Skipping coverage for this file.", fullPath);
                    filesSkipped++;
                    continue;
                }

                // Create a new coverage measure for this file
                NewCoverage coverage = context.newCoverage().onFile(inputFile);

                // Process line coverage data
                JsonArray lineCoverageArray = fileData.get("LineCoverage").getAsJsonArray();

                for (JsonElement lineElement : lineCoverageArray) {
                    JsonObject lineData = lineElement.getAsJsonObject();

                    int lineNumber = lineData.get("Line").getAsInt();
                    boolean isCode = lineData.get("IsCode").getAsBoolean();
                    int hits = lineData.get("Hits").getAsInt();

                    // Only report coverage for lines with code
                    if (isCode) {
                        coverage.lineHits(lineNumber, hits);
                    }
                }

                // Save the coverage data
                coverage.save();
                filesProcessed++;

                if (LOG.isDebugEnabled()) {
                    int coveredLines = fileData.get("CoveredLines").getAsInt();
                    int codeLines = fileData.get("CodeLines").getAsInt();
                    double coveragePercent = fileData.get("Coverage").getAsDouble() * 100.0;
                    LOG.debug("Coverage imported for {}: {}/{} lines ({}%)",
                        fileName, coveredLines, codeLines, String.format("%.1f", coveragePercent));
                }
            }

            LOG.info("Coverage import complete: {} files processed, {} files skipped", filesProcessed, filesSkipped);

        } catch (IOException e) {
            String message = String.format("Failed to read coverage file: %s", coverageFile.getAbsolutePath());
            LOG.error(message, e);
            throw new IOException(message, e);
        } catch (Exception e) {
            String message = String.format("Failed to parse coverage data from: %s", coverageFile.getAbsolutePath());
            LOG.error(message, e);
            throw new IOException(message, e);
        }
    }

    /**
     * Find the InputFile in the SonarQube file system that matches the given path.
     *
     * Tries multiple strategies:
     * 1. Exact absolute path match
     * 2. Relative path match (from project base directory)
     * 3. Filename match (if unique)
     */
    private InputFile findInputFile(FileSystem fs, String fullPath, String fileName) {
        // Strategy 1: Try absolute path
        Path absolutePath = Paths.get(fullPath);
        InputFile inputFile = fs.inputFile(fs.predicates().hasAbsolutePath(absolutePath.toString()));

        if (inputFile != null) {
            return inputFile;
        }

        // Strategy 2: Try relative path from project base directory
        Path basePath = fs.baseDir().toPath();
        Path relativePath = basePath.relativize(absolutePath);
        inputFile = fs.inputFile(fs.predicates().hasRelativePath(relativePath.toString()));

        if (inputFile != null) {
            return inputFile;
        }

        // Strategy 3: Try to find by filename (only if unique)
        Iterable<InputFile> matchingFiles = fs.inputFiles(
            fs.predicates().matchesPathPattern("**/" + fileName + ".*")
        );

        // Check if we have exactly one match
        int count = 0;
        InputFile candidate = null;
        for (InputFile file : matchingFiles) {
            count++;
            candidate = file;
        }

        if (count == 1) {
            return candidate;
        }

        return null;
    }
}
