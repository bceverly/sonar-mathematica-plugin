package org.sonar.plugins.mathematica.sca;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.sonar.api.issue.impact.Severity;

/**
 * Database of known vulnerable Mathematica paclets.
 *
 * This database contains security vulnerabilities, deprecated packages,
 * and paclets with known issues that should be flagged during analysis.
 *
 * NOTE: This is a curated list. Add new vulnerabilities as they are discovered.
 */
public final class PacletVulnerabilityDatabase {

    private PacletVulnerabilityDatabase() {
        throw new UnsupportedOperationException("Utility class");
    }

    private static final Map<String, List<Vulnerability>> KNOWN_VULNERABILITIES = new HashMap<>();

    static {
        // Example vulnerable/deprecated paclets
        // Add real CVEs and vulnerabilities as they are discovered

        // Deprecated HTTP client (example)
        addVulnerability("HTTPClient", "< 2.0",
            "DEPRECATED-001",
            "HTTPClient versions prior to 2.0 do not properly validate SSL certificates",
            Severity.HIGH,
            "Upgrade to HTTPClient 2.0 or later, or use URLRead with proper SSL validation"
        );

        // Insecure crypto (example)
        addVulnerability("CryptoUtils", "< 1.5",
            "CVE-MATHEMATICA-2020-001",
            "Uses weak encryption algorithms (MD5, SHA1) for cryptographic operations",
            Severity.MEDIUM,
            "Upgrade to CryptoUtils 1.5+ which uses SHA256 and modern crypto"
        );

        // SQL injection prone package (example)
        addVulnerability("DatabaseLink", "< 9.0",
            "SECURITY-003",
            "DatabaseLink versions < 9.0 may be vulnerable to SQL injection when using string concatenation",
            Severity.HIGH,
            "Upgrade to DatabaseLink 9.0+ and use SQLBind for parameterized queries"
        );

        // Outdated ML package (example)
        addVulnerability("NeuralNetworks", "< 12.0",
            "DEPRECATED-002",
            "NeuralNetworks package is deprecated. Use built-in NetTrain instead.",
            Severity.LOW,
            "Migrate to Mathematica's built-in neural network functions (NetTrain, NetChain, etc.)"
        );

        // Path traversal vulnerability (example)
        addVulnerability("FileUtilities", "1.0 - 1.3",
            "CVE-MATHEMATICA-2021-005",
            "Path traversal vulnerability in FileUtilities when handling user-provided file paths",
            Severity.HIGH,
            "Upgrade to FileUtilities 1.4+ or validate all file paths before use"
        );

        // Deprecated cloud package
        addVulnerability("CloudDeploy", "< 11.0",
            "DEPRECATED-003",
            "Early CloudDeploy versions have insecure default permissions",
            Severity.MEDIUM,
            "Upgrade to Mathematica 11.0+ and explicitly set Permissions in CloudDeploy"
        );

        // IMPORTANT: Add real vulnerabilities here as they are discovered
        // Sources:
        // - Wolfram Security Bulletins
        // - CVE Database (search for "Mathematica" or "Wolfram")
        // - Community reports
        // - Internal security audits
    }

    /**
     * Add a vulnerability to the database.
     */
    private static void addVulnerability(String pacletName, String affectedVersions,
                                        String identifier, String description,
                                        Severity severity, String remediation) {
        KNOWN_VULNERABILITIES
            .computeIfAbsent(pacletName, k -> new ArrayList<>())
            .add(new Vulnerability(identifier, description, severity, affectedVersions, remediation));
    }

    /**
     * Check if a dependency has known vulnerabilities.
     *
     * @param dependency The paclet dependency to check
     * @return List of applicable vulnerabilities (empty if none)
     */
    public static List<Vulnerability> checkDependency(PacletDependency dependency) {
        List<Vulnerability> vulns = KNOWN_VULNERABILITIES.get(dependency.getName());
        if (vulns == null) {
            return new ArrayList<>();
        }

        List<Vulnerability> applicable = new ArrayList<>();
        for (Vulnerability vuln : vulns) {
            if (isVersionAffected(dependency.getVersion(), vuln.getAffectedVersions())) {
                applicable.add(vuln);
            }
        }

        return applicable;
    }

    /**
     * Check if a version is affected by the vulnerability.
     *
     * Supports version ranges like:
     * - "< 2.0" - all versions less than 2.0
     * - "> 1.0" - all versions greater than 1.0
     * - "1.0 - 1.3" - versions from 1.0 to 1.3 inclusive
     * - "1.5" - exact version match
     */
    private static boolean isVersionAffected(String actualVersion, String affectedRange) {
        // Handle "unknown" version - flag as potentially affected
        if ("unknown".equals(actualVersion)) {
            return true;
        }

        try {
            // Remove "+" suffix from version strings (e.g., "1.0+" -> "1.0")
            String cleanActual = actualVersion.replaceAll("\\+$", "");

            if (affectedRange.startsWith("<")) {
                // Example: "< 2.0"
                String threshold = affectedRange.substring(1).trim();
                return compareVersions(cleanActual, threshold) < 0;
            } else if (affectedRange.startsWith(">")) {
                // Example: "> 1.0"
                String threshold = affectedRange.substring(1).trim();
                return compareVersions(cleanActual, threshold) > 0;
            } else if (affectedRange.contains("-")) {
                // Example: "1.0 - 1.3"
                String[] parts = affectedRange.split("-");
                String min = parts[0].trim();
                String max = parts[1].trim();
                return compareVersions(cleanActual, min) >= 0
                       && compareVersions(cleanActual, max) <= 0;
            } else {
                // Exact match
                return cleanActual.equals(affectedRange.trim());
            }
        } catch (Exception e) {
            // If version parsing fails, assume affected for safety
            return true;
        }
    }

    /**
     * Compare two version strings.
     *
     * @return negative if v1 < v2, 0 if equal, positive if v1 > v2
     */
    private static int compareVersions(String v1, String v2) {
        String[] parts1 = v1.split("\\.");
        String[] parts2 = v2.split("\\.");

        int maxLength = Math.max(parts1.length, parts2.length);

        for (int i = 0; i < maxLength; i++) {
            int num1 = i < parts1.length ? parseVersionPart(parts1[i]) : 0;
            int num2 = i < parts2.length ? parseVersionPart(parts2[i]) : 0;

            if (num1 != num2) {
                return Integer.compare(num1, num2);
            }
        }

        return 0;
    }

    /**
     * Parse a version part to integer, handling non-numeric suffixes.
     */
    private static int parseVersionPart(String part) {
        try {
            // Extract leading digits only
            return Integer.parseInt(part.replaceAll("\\D.*", ""));
        } catch (NumberFormatException e) {
            return 0;
        }
    }

    /**
     * Represents a known vulnerability.
     */
    public static class Vulnerability {
        private final String identifier;
        private final String description;
        private final Severity severity;
        private final String affectedVersions;
        private final String remediation;

        public Vulnerability(String identifier, String description, Severity severity,
                           String affectedVersions, String remediation) {
            this.identifier = identifier;
            this.description = description;
            this.severity = severity;
            this.affectedVersions = affectedVersions;
            this.remediation = remediation;
        }

        public String getIdentifier() {
            return identifier;
        }

        public String getDescription() {
            return description;
        }

        public Severity getSeverity() {
            return severity;
        }

        public String getAffectedVersions() {
            return affectedVersions;
        }

        public String getRemediation() {
            return remediation;
        }
    }
}
