package org.sonar.plugins.mathematica.ast;

import org.sonar.api.batch.fs.InputFile;
import org.sonar.api.batch.sensor.SensorContext;
import org.sonar.plugins.mathematica.rules.MathematicaRulesDefinition;
import org.sonar.plugins.mathematica.rules.MathematicaRulesSensor;

import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.regex.Pattern;

/**
 * AST visitor that detects all 21 vulnerability patterns in a single tree walk.
 *
 * PERFORMANCE: This replaces 21 sequential regex scans with one AST traversal,
 * providing massive performance improvements for large files.
 *
 * Detected vulnerabilities:
 * 1. HardcodedCredentials
 * 2. CommandInjection
 * 3. SqlInjection
 * 4. CodeInjection
 * 5. PathTraversal
 * 6. WeakCryptography
 * 7. SSRF
 * 8. InsecureDeserialization
 * 9. UnsafeSymbol
 * 10. XXE
 * 11. MissingSanitization
 * 12. InsecureRandomExpanded
 * 13. UnsafeCloudDeploy
 * 14. DynamicInjection
 * 15. ToExpressionOnInput
 * 16. UnsanitizedRunProcess
 * 17. MissingCloudAuth
 * 18. HardcodedApiKeys
 * 19. NeedsGetUntrusted
 * 20. ExposingSensitiveData
 * 21. MissingFormFunctionValidation
 */
public class VulnerabilityVisitor implements AstVisitor {

    private final SensorContext context;
    private final InputFile inputFile;
    private final MathematicaRulesSensor sensor;

    // Track variables that might be user input for taint analysis
    private final Set<String> userInputVariables = new HashSet<>();

    // PROFILING: Track time spent in each check
    private long totalCheckTime = 0;
    private int functionCallCount = 0;
    private int literalCount = 0;

    // Security-sensitive keywords
    private static final Set<String> CREDENTIAL_KEYWORDS = new HashSet<>(Arrays.asList(
        "password", "passwd", "pwd", "secret", "apikey", "api_key", "token",
        "auth", "credential", "private_key", "access_key", "secret_key",
        "aws_access_key_id", "aws_secret_access_key"
    ));

    private static final Set<String> USER_INPUT_FUNCTIONS = new HashSet<>(Arrays.asList(
        "Import", "Input", "InputString", "URLFetch", "URLRead", "URLExecute",
        "APIFunction", "FormFunction", "CloudGet"
    ));

    private static final Set<String> DANGEROUS_FILE_OPS = new HashSet<>(Arrays.asList(
        "DeleteFile", "DeleteDirectory", "RenameFile", "SystemOpen",
        "CreateDirectory", "CopyFile", "CopyDirectory"
    ));

    private static final Set<String> SYSTEM_VARIABLES = new HashSet<>(Arrays.asList(
        "$UserName", "$MachineName", "$HomeDirectory", "$InstallationDirectory",
        "$ProcessID", "SystemCredential"
    ));

    private static final Pattern API_KEY_PATTERN = Pattern.compile("[a-zA-Z0-9_\\-]{20,}");

    public VulnerabilityVisitor(SensorContext context, InputFile inputFile, MathematicaRulesSensor sensor) {
        this.context = context;
        this.inputFile = inputFile;
        this.sensor = sensor;
    }

    @Override
    public void visit(FunctionDefNode node) {
        // Check function body for vulnerabilities
        visitChildren(node);
    }

    @Override
    public void visit(FunctionCallNode node) {
        functionCallCount++;
        long startCheck = System.currentTimeMillis();

        String funcName = node.getFunctionName();
        List<AstNode> args = node.getArguments();

        // Track user input for taint analysis
        if (USER_INPUT_FUNCTIONS.contains(funcName) && args != null && !args.isEmpty()) {
            trackUserInput(node);
        }

        // Check specific vulnerability patterns
        checkCommandInjection(node, funcName, args);
        checkSqlInjection(node, funcName, args);
        checkCodeInjection(node, funcName, args);
        checkPathTraversal(node, funcName, args);
        checkWeakCryptography(node, funcName, args);
        checkSSRF(node, funcName, args);
        checkInsecureDeserialization(node, funcName, args);
        checkUnsafeSymbol(node, funcName, args);
        checkXXE(node, funcName, args);
        checkMissingSanitization(node, funcName, args);
        checkInsecureRandom(node, funcName, args);
        checkUnsafeCloudDeploy(node, funcName, args);
        checkDynamicInjection(node, funcName, args);
        checkToExpressionOnInput(node, funcName, args);
        checkUnsanitizedRunProcess(node, funcName, args);
        checkMissingCloudAuth(node, funcName, args);
        checkNeedsGetUntrusted(node, funcName, args);
        checkExposingSensitiveData(node, funcName, args);
        checkMissingFormFunctionValidation(node, funcName, args);

        totalCheckTime += (System.currentTimeMillis() - startCheck);

        // Recurse into arguments
        visitChildren(node);
    }

    @Override
    public void visit(IdentifierNode node) {
        // Check for exposed system variables in cloud contexts
        String name = node.getName();
        if (SYSTEM_VARIABLES.contains(name)) {
            // This will be caught in checkExposingSensitiveData if in CloudDeploy context
        }
    }

    @Override
    public void visit(LiteralNode node) {
        literalCount++;
        // Check for hardcoded credentials and API keys in string literals
        if (node.getValue() instanceof String) {
            String value = (String) node.getValue();
            checkHardcodedCredentials(node, value);
            checkHardcodedApiKeys(node, value);
        }
    }

    /**
     * Report profiling statistics after visitor completes.
     */
    public void reportProfileStats() {
        if (functionCallCount > 0 && totalCheckTime > 1000) {
            double avgPerCall = (double) totalCheckTime / functionCallCount;
            System.out.println(String.format(
                "PROFILE Visitor: %s - funcCalls=%d, literals=%d, totalCheckTime=%dms, avgPerCall=%.2fms",
                inputFile.filename(), functionCallCount, literalCount, totalCheckTime, avgPerCall));
        }
    }

    // ========== Vulnerability Detection Methods ==========

    private void checkHardcodedCredentials(LiteralNode node, String value) {
        // Check if this looks like a credential assignment
        // This is simplified - in full implementation, check parent context
        if (value.length() >= 8 && !isPlaceholder(value)) {
            // Report if parent is an assignment to a credential-related variable
            reportIssue(node.getStartLine(), MathematicaRulesDefinition.HARDCODED_CREDENTIALS_KEY,
                "Avoid hardcoding credentials. Use SystemCredential[] or environment variables.");
        }
    }

    private void checkCommandInjection(FunctionCallNode node, String funcName, List<AstNode> args) {
        if (("Run".equals(funcName) || "RunProcess".equals(funcName)) && args != null && !args.isEmpty()) {
            // Check if first argument contains string concatenation or variables
            AstNode firstArg = args.get(0);
            if (containsConcatenation(firstArg) || containsVariable(firstArg)) {
                reportIssue(node.getStartLine(), MathematicaRulesDefinition.COMMAND_INJECTION_KEY,
                    "Make sure that executing this OS command is safe.");
            }
        }
    }

    private void checkSqlInjection(FunctionCallNode node, String funcName, List<AstNode> args) {
        Set<String> sqlFunctions = new HashSet<>(Arrays.asList(
            "SQLExecute", "SQLSelect", "SQLInsert", "SQLUpdate", "SQLDelete"
        ));

        if (sqlFunctions.contains(funcName) && args != null && args.size() >= 2) {
            // Check if query (2nd arg) contains string concatenation
            AstNode queryArg = args.get(1);
            if (containsConcatenation(queryArg)) {
                reportIssue(node.getStartLine(), MathematicaRulesDefinition.SQL_INJECTION_KEY,
                    "Use parameterized queries to prevent SQL injection.");
            }
        }
    }

    private void checkCodeInjection(FunctionCallNode node, String funcName, List<AstNode> args) {
        if (("ToExpression".equals(funcName) || "Evaluate".equals(funcName))
            && args != null && !args.isEmpty()) {

            AstNode firstArg = args.get(0);
            // If first arg is not a string literal, it's potentially dangerous
            if (!(firstArg instanceof LiteralNode && ((LiteralNode) firstArg).getValue() instanceof String)) {
                reportIssue(node.getStartLine(), MathematicaRulesDefinition.CODE_INJECTION_KEY,
                    "Make sure that evaluating this expression is safe.");
            }
        }
    }

    private void checkPathTraversal(FunctionCallNode node, String funcName, List<AstNode> args) {
        Set<String> fileOps = new HashSet<>(Arrays.asList(
            "Import", "Export", "Get", "Put", "OpenRead", "OpenWrite", "OpenAppend"
        ));

        if (fileOps.contains(funcName) && args != null && !args.isEmpty()) {
            AstNode pathArg = args.get(0);
            if (containsConcatenation(pathArg) || containsVariable(pathArg)) {
                reportIssue(node.getStartLine(), MathematicaRulesDefinition.PATH_TRAVERSAL_KEY,
                    "Validate and sanitize this file path to prevent path traversal attacks.");
            }
        }
    }

    private void checkWeakCryptography(FunctionCallNode node, String funcName, List<AstNode> args) {
        if ("Hash".equals(funcName) && args != null && args.size() >= 2) {
            AstNode algoArg = args.get(1);
            if (algoArg instanceof LiteralNode) {
                String algo = String.valueOf(((LiteralNode) algoArg).getValue());
                if ("MD5".equals(algo) || "SHA1".equals(algo) || "SHA-1".equals(algo)) {
                    reportIssue(node.getStartLine(), MathematicaRulesDefinition.WEAK_CRYPTOGRAPHY_KEY,
                        "Use a stronger hash algorithm (SHA256, SHA512) instead of MD5/SHA1.");
                }
            }
        } else if ("Random".equals(funcName)) {
            reportIssue(node.getStartLine(), MathematicaRulesDefinition.WEAK_CRYPTOGRAPHY_KEY,
                "Use RandomInteger instead of Random for security-sensitive operations.");
        }
    }

    private void checkSSRF(FunctionCallNode node, String funcName, List<AstNode> args) {
        Set<String> urlFunctions = new HashSet<>(Arrays.asList(
            "URLFetch", "URLRead", "URLExecute", "ServiceExecute"
        ));

        if (urlFunctions.contains(funcName) && args != null && !args.isEmpty()) {
            AstNode urlArg = args.get(0);
            if (containsConcatenation(urlArg) || containsVariable(urlArg)) {
                reportIssue(node.getStartLine(), MathematicaRulesDefinition.SSRF_KEY,
                    "Validate and sanitize URLs to prevent Server-Side Request Forgery attacks.");
            }
        }
    }

    private void checkInsecureDeserialization(FunctionCallNode node, String funcName, List<AstNode> args) {
        if ("Import".equals(funcName) && args != null && args.size() >= 2) {
            AstNode formatArg = args.get(1);
            if (formatArg instanceof LiteralNode) {
                String format = String.valueOf(((LiteralNode) formatArg).getValue());
                if ("MX".equals(format) || "WDX".equals(format)) {
                    reportIssue(node.getStartLine(), MathematicaRulesDefinition.INSECURE_DESERIALIZATION_KEY,
                        "Avoid importing MX/WDX files from untrusted sources. Use safe formats like JSON or CSV.");
                }
            }
        } else if ("Get".equals(funcName) && args != null && !args.isEmpty()) {
            AstNode pathArg = args.get(0);
            if (containsUrl(pathArg)) {
                reportIssue(node.getStartLine(), MathematicaRulesDefinition.INSECURE_DESERIALIZATION_KEY,
                    "Avoid loading code from untrusted sources with Get[]. Validate file paths and check integrity.");
            }
        }
    }

    private void checkUnsafeSymbol(FunctionCallNode node, String funcName, List<AstNode> args) {
        if ("Symbol".equals(funcName) || "ToExpression".equals(funcName)) {
            reportIssue(node.getStartLine(), MathematicaRulesDefinition.UNSAFE_SYMBOL_KEY,
                "Using Symbol[] or ToExpression with user input allows code injection. Use whitelist instead.");
        }
    }

    private void checkXXE(FunctionCallNode node, String funcName, List<AstNode> args) {
        if ("Import".equals(funcName) && args != null && args.size() >= 2) {
            AstNode formatArg = args.get(1);
            if (formatArg instanceof LiteralNode && "XML".equals(String.valueOf(((LiteralNode) formatArg).getValue()))) {
                // Check if ProcessDTD option is present (simplified - full check would parse options)
                reportIssue(node.getStartLine(), MathematicaRulesDefinition.XXE_KEY,
                    "XML import without ProcessDTD->False is vulnerable to XXE attacks.");
            }
        }
    }

    private void checkMissingSanitization(FunctionCallNode node, String funcName, List<AstNode> args) {
        if (DANGEROUS_FILE_OPS.contains(funcName)) {
            reportIssue(node.getStartLine(), MathematicaRulesDefinition.MISSING_SANITIZATION_KEY,
                "Dangerous function should only accept validated input. Verify path/input is sanitized.");
        }
    }

    private void checkInsecureRandom(FunctionCallNode node, String funcName, List<AstNode> args) {
        if ("Random".equals(funcName) || "RandomChoice".equals(funcName)) {
            // Check context - simplified version
            reportIssue(node.getStartLine(), MathematicaRulesDefinition.INSECURE_RANDOM_EXPANDED_KEY,
                "Using Random/RandomChoice for security tokens is insecure. Use RandomInteger instead.");
        }
    }

    private void checkUnsafeCloudDeploy(FunctionCallNode node, String funcName, List<AstNode> args) {
        if ("CloudDeploy".equals(funcName)) {
            // Check if Permissions option is present (simplified)
            boolean hasPermissions = false;
            if (args != null) {
                for (AstNode arg : args) {
                    if (containsIdentifier(arg, "Permissions")) {
                        hasPermissions = true;
                        break;
                    }
                }
            }
            if (!hasPermissions) {
                reportIssue(node.getStartLine(), MathematicaRulesDefinition.UNSAFE_CLOUD_DEPLOY_KEY,
                    "CloudDeploy without explicit Permissions exposes code publicly. Specify Permissions option.");
            }
        }
    }

    private void checkDynamicInjection(FunctionCallNode node, String funcName, List<AstNode> args) {
        if ("Dynamic".equals(funcName) && args != null && !args.isEmpty()) {
            // Check if Dynamic contains ToExpression or Symbol
            if (containsFunctionCall(args.get(0), "ToExpression")
                || containsFunctionCall(args.get(0), "Symbol")) {
                reportIssue(node.getStartLine(), MathematicaRulesDefinition.DYNAMIC_INJECTION_KEY,
                    "Dynamic[] with ToExpression/Symbol allows code injection. Validate and whitelist inputs.");
            }
        }
    }

    private void checkToExpressionOnInput(FunctionCallNode node, String funcName, List<AstNode> args) {
        if ("ToExpression".equals(funcName) && args != null && !args.isEmpty()) {
            // Check if argument is a user input variable
            AstNode arg = args.get(0);
            if (arg instanceof IdentifierNode) {
                String varName = ((IdentifierNode) arg).getName();
                if (userInputVariables.contains(varName)
                    || varName.toLowerCase().contains("input")
                    || varName.toLowerCase().contains("user")
                    || varName.toLowerCase().contains("request")) {
                    reportIssue(node.getStartLine(), MathematicaRulesDefinition.TOEXPRESSION_ON_INPUT_KEY,
                        "CRITICAL: ToExpression on external input enables arbitrary code execution. Use Interpreter[] instead.");
                }
            }
        }
    }

    private void checkUnsanitizedRunProcess(FunctionCallNode node, String funcName, List<AstNode> args) {
        if (("RunProcess".equals(funcName) || "Run".equals(funcName)) && args != null && !args.isEmpty()) {
            AstNode cmdArg = args.get(0);
            if (containsUserInputVariable(cmdArg)) {
                reportIssue(node.getStartLine(), MathematicaRulesDefinition.UNSANITIZED_RUNPROCESS_KEY,
                    "CRITICAL: RunProcess/Run with user input enables command injection. Validate and sanitize inputs.");
            }
        }
    }

    private void checkMissingCloudAuth(FunctionCallNode node, String funcName, List<AstNode> args) {
        if ("CloudDeploy".equals(funcName) && args != null && !args.isEmpty()) {
            // Check if first arg is APIFunction or FormFunction
            AstNode firstArg = args.get(0);
            if (firstArg instanceof FunctionCallNode) {
                FunctionCallNode innerFunc = (FunctionCallNode) firstArg;
                if ("APIFunction".equals(innerFunc.getFunctionName())
                    || "FormFunction".equals(innerFunc.getFunctionName())) {
                    checkCloudFunctionPermissions(node, args);
                }
            }
        }
    }

    private void checkCloudFunctionPermissions(FunctionCallNode node, List<AstNode> args) {
        // Check for Permissions
        boolean hasPermissions = false;
        if (args.size() > 1) {
            for (int i = 1; i < args.size(); i++) {
                if (containsIdentifier(args.get(i), "Permissions")) {
                    hasPermissions = true;
                    break;
                }
            }
        }
        if (!hasPermissions) {
            reportIssue(node.getStartLine(), MathematicaRulesDefinition.MISSING_CLOUD_AUTH_KEY,
                "CRITICAL: Cloud function without Permissions is publicly accessible. Add Permissions -> \"Private\" or specific users.");
        }
    }

    private void checkNeedsGetUntrusted(FunctionCallNode node, String funcName, List<AstNode> args) {
        if (("Needs".equals(funcName) || "Get".equals(funcName)) && args != null && !args.isEmpty()) {
            AstNode pathArg = args.get(0);
            if (containsUserInputVariable(pathArg)) {
                reportIssue(node.getStartLine(), MathematicaRulesDefinition.NEEDS_GET_UNTRUSTED_KEY,
                    "CRITICAL: Loading package from user-controlled path enables code execution. Validate against whitelist.");
            }
        }
    }

    private void checkExposingSensitiveData(FunctionCallNode node, String funcName, List<AstNode> args) {
        if ("CloudDeploy".equals(funcName) && args != null && !args.isEmpty()) {
            // Check if function body contains system variables
            for (AstNode arg : args) {
                if (containsSystemVariable(arg)) {
                    reportIssue(node.getStartLine(), MathematicaRulesDefinition.EXPOSING_SENSITIVE_DATA_KEY,
                        "Cloud function exposes sensitive system information ($UserName, credentials, etc.).");
                    break;
                }
            }
        }
    }

    private void checkMissingFormFunctionValidation(FunctionCallNode node, String funcName, List<AstNode> args) {
        if ("FormFunction".equals(funcName) && args != null && !args.isEmpty()) {
            // Check if first arg (form fields) has validation (simplified)
            AstNode fieldsArg = args.get(0);
            boolean hasValidation = containsIdentifier(fieldsArg, "Restricted")
                                   || containsIdentifier(fieldsArg, "Interpreter");
            if (!hasValidation) {
                reportIssue(node.getStartLine(), MathematicaRulesDefinition.MISSING_FORMFUNCTION_VALIDATION_KEY,
                    "FormFunction inputs lack validation. Use Restricted[], Interpreter[], or type constraints.");
            }
        }
    }

    private void checkHardcodedApiKeys(LiteralNode node, String value) {
        // Check if string looks like an API key (20+ alphanumeric chars)
        if (value.length() >= 20 && API_KEY_PATTERN.matcher(value).matches()) {
            reportIssue(node.getStartLine(), MathematicaRulesDefinition.HARDCODED_API_KEYS_KEY,
                "CRITICAL: Hardcoded API key/token found. Use SystemCredential[] instead.");
        }
    }

    // ========== Helper Methods ==========

    private void trackUserInput(FunctionCallNode node) {
        // Track variables assigned from user input functions
        // This is simplified - full implementation would track through assignments
        String funcName = node.getFunctionName();
        if (USER_INPUT_FUNCTIONS.contains(funcName)) {
            // Mark this as user input context
            userInputVariables.add("__user_input_context__");
        }
    }

    private boolean containsConcatenation(AstNode node) {
        if (node instanceof OperatorNode) {
            OperatorNode op = (OperatorNode) node;
            return "<>".equals(op.getOperatorSymbol()) || "~~".equals(op.getOperatorSymbol());
        }
        for (AstNode child : node.getChildren()) {
            if (containsConcatenation(child)) {
                return true;
            }
        }
        return false;
    }

    private boolean containsVariable(AstNode node) {
        if (node instanceof IdentifierNode) {
            return true;
        }
        for (AstNode child : node.getChildren()) {
            if (containsVariable(child)) {
                return true;
            }
        }
        return false;
    }

    private boolean containsUserInputVariable(AstNode node) {
        if (node instanceof IdentifierNode) {
            String name = ((IdentifierNode) node).getName();
            return userInputVariables.contains(name)
                   || name.toLowerCase().contains("input")
                   || name.toLowerCase().contains("user")
                   || name.toLowerCase().contains("request");
        }
        for (AstNode child : node.getChildren()) {
            if (containsUserInputVariable(child)) {
                return true;
            }
        }
        return false;
    }

    private boolean containsUrl(AstNode node) {
        if (node instanceof LiteralNode) {
            Object val = ((LiteralNode) node).getValue();
            if (val instanceof String) {
                String str = (String) val;
                return str.startsWith("http://") || str.startsWith("https://");
            }
        }
        return false;
    }

    private boolean containsIdentifier(AstNode node, String name) {
        if (node instanceof IdentifierNode && name.equals(((IdentifierNode) node).getName())) {
            return true;
        }
        for (AstNode child : node.getChildren()) {
            if (containsIdentifier(child, name)) {
                return true;
            }
        }
        return false;
    }

    private boolean containsFunctionCall(AstNode node, String funcName) {
        if (node instanceof FunctionCallNode && funcName.equals(((FunctionCallNode) node).getFunctionName())) {
            return true;
        }
        for (AstNode child : node.getChildren()) {
            if (containsFunctionCall(child, funcName)) {
                return true;
            }
        }
        return false;
    }

    private boolean containsSystemVariable(AstNode node) {
        if (node instanceof IdentifierNode) {
            String name = ((IdentifierNode) node).getName();
            return SYSTEM_VARIABLES.contains(name);
        }
        for (AstNode child : node.getChildren()) {
            if (containsSystemVariable(child)) {
                return true;
            }
        }
        return false;
    }

    private boolean isPlaceholder(String value) {
        String lower = value.toLowerCase();
        return lower.contains("example") || lower.contains("placeholder")
               || lower.contains("your_") || lower.contains("xxx")
               || lower.equals("password") || lower.equals("secret")
               || value.matches("^[*]+$") || value.matches("^[x]+$");
    }

    private void reportIssue(int line, String ruleKey, String message) {
        if (sensor != null) {
            sensor.queueIssue(inputFile, line, ruleKey, message);
        }
    }
}
