package org.sonar.plugins.mathematica.rules;

import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.sonar.api.batch.fs.InputFile;
import org.sonar.api.batch.sensor.SensorContext;

/**
 * Detector for Vulnerability/Security rules (14 rules total).
 * Handles injection attacks, insecure APIs, and security weaknesses.
 */
public class VulnerabilityDetector extends BaseDetector {

    // ===== PATTERNS FOR VULNERABILITY DETECTION =====

    private static final Pattern HARDCODED_CREDENTIAL_PATTERN = Pattern.compile(
        "(?i)(password|passwd|pwd|secret|apikey|api_key|token|auth|credential|private_key|" +
        "access_key|secret_key|aws_access_key_id|aws_secret_access_key)\\s*=\\s*\"([^\"]{8,})\"",
        Pattern.CASE_INSENSITIVE
    );
    private static final Pattern COMMAND_INJECTION_PATTERN = Pattern.compile(
        "(?:Run|RunProcess|Import)\\s*\\[\\s*(?:\"[^\"]*\"\\s*<>|\\{\"sh\"|\\{\"bash\"|\"!\"\\s*<>)"
    );
    private static final Pattern SQL_INJECTION_PATTERN = Pattern.compile(
        "(?:SQLExecute|SQLSelect|SQLInsert|SQLUpdate|SQLDelete)\\s*\\[[^,]*,\\s*\"[^\"]*\"\\s*<>"
    );
    private static final Pattern CODE_INJECTION_PATTERN = Pattern.compile(
        "(?:ToExpression|Evaluate)\\s*\\[\\s*(?!\")"
    );
    private static final Pattern PATH_TRAVERSAL_PATTERN = Pattern.compile(
        "(?:Import|Export|Get|Put|OpenRead|OpenWrite|OpenAppend)\\s*\\[[^\\]]*<>[^\\]]*\\]"
    );
    private static final Pattern WEAK_CRYPTO_PATTERN = Pattern.compile(
        "(?:Hash\\s*\\[[^,]+,\\s*\"(?:MD5|SHA1|SHA-1)\")|(?:Random\\s*\\[)"
    );
    private static final Pattern SSRF_PATTERN = Pattern.compile(
        "(?:URLFetch|URLRead|URLExecute|ServiceExecute)\\s*\\[[^\\]]*<>|" +
        "Import\\s*\\[\\s*(?:\"https?://\"|\"http://\")\\s*<>"
    );
    private static final Pattern INSECURE_DESERIALIZATION_PATTERN = Pattern.compile(
        "(?:Import\\s*\\[[^,]+,\\s*\"(?:MX|WDX)\")|" +
        "(?:Get\\s*\\[(?:[^\\]]*<>|\"https?://))"
    );

    // Phase 2 Vulnerability patterns
    private static final Pattern SYMBOL_PATTERN = Pattern.compile("Symbol\\s*\\[|ToExpression\\s*\\[");
    private static final Pattern XML_IMPORT_PATTERN = Pattern.compile("Import\\s*\\[[^,]+,\\s*\"XML\"");
    private static final Pattern DANGEROUS_FUNCTIONS_PATTERN = Pattern.compile(
        "(?:DeleteFile|DeleteDirectory|RenameFile|SystemOpen)\\s*\\["
    );
    private static final Pattern RANDOM_CHOICE_PATTERN = Pattern.compile("RandomChoice\\s*\\[|Random\\s*\\[");

    // Phase 3 Security patterns
    private static final Pattern CLOUD_DEPLOY_PATTERN = Pattern.compile("CloudDeploy\\s*\\[[^,\\]]+\\s*\\]");
    private static final Pattern DYNAMIC_TOEXPRESSION_PATTERN = Pattern.compile(
        "Dynamic\\s*\\[[^\\]]*(?:ToExpression|Symbol)\\s*\\["
    );

    /**
     * Detect hardcoded credentials.
     */
    public void detectHardcodedCredentials(SensorContext context, InputFile inputFile, String content) {
        try {
            Matcher matcher = HARDCODED_CREDENTIAL_PATTERN.matcher(content);

            while (matcher.find()) {
                String variableName = matcher.group(1);
                String value = matcher.group(2);

                // Skip placeholders
                if (isPlaceholderValue(value)) {
                    continue;
                }

                int lineNumber = calculateLineNumber(content, matcher.start());
                reportIssue(context, inputFile, lineNumber, MathematicaRulesDefinition.HARDCODED_CREDENTIALS_KEY,
                    String.format("Remove this hard-coded credential '%s'.", variableName));
            }
        } catch (Exception e) {
            LOG.warn("Skipping hardcoded credential detection due to error in file: {}", inputFile.filename());
        }
    }

    /**
     * Check if a value looks like a placeholder.
     */
    private boolean isPlaceholderValue(String value) {
        String lower = value.toLowerCase();

        if (lower.contains("example") || lower.contains("placeholder") || lower.contains("your_")) {
            return true;
        }
        if (lower.contains("xxx") || lower.equals("password") || lower.equals("secret")) {
            return true;
        }

        return value.matches("^[*]+$") || value.matches("^[x]+$");
    }

    /**
     * Detect command injection vulnerabilities.
     */
    public void detectCommandInjection(SensorContext context, InputFile inputFile, String content) {
        try {
            Matcher matcher = COMMAND_INJECTION_PATTERN.matcher(content);

            while (matcher.find()) {
                int lineNumber = calculateLineNumber(content, matcher.start());
                reportIssue(context, inputFile, lineNumber, MathematicaRulesDefinition.COMMAND_INJECTION_KEY,
                    "Make sure that executing this OS command is safe.");
            }
        } catch (Exception e) {
            LOG.warn("Skipping command injection detection due to error in file: {}", inputFile.filename());
        }
    }

    /**
     * Detect SQL injection vulnerabilities.
     */
    public void detectSqlInjection(SensorContext context, InputFile inputFile, String content) {
        try {
            Matcher matcher = SQL_INJECTION_PATTERN.matcher(content);

            while (matcher.find()) {
                int lineNumber = calculateLineNumber(content, matcher.start());
                reportIssue(context, inputFile, lineNumber, MathematicaRulesDefinition.SQL_INJECTION_KEY,
                    "Use parameterized queries to prevent SQL injection.");
            }
        } catch (Exception e) {
            LOG.warn("Skipping SQL injection detection due to error in file: {}", inputFile.filename());
        }
    }

    /**
     * Detect code injection via ToExpression.
     */
    public void detectCodeInjection(SensorContext context, InputFile inputFile, String content) {
        try {
            Matcher matcher = CODE_INJECTION_PATTERN.matcher(content);

            while (matcher.find()) {
                int lineNumber = calculateLineNumber(content, matcher.start());
                reportIssue(context, inputFile, lineNumber, MathematicaRulesDefinition.CODE_INJECTION_KEY,
                    "Make sure that evaluating this expression is safe.");
            }
        } catch (Exception e) {
            LOG.warn("Skipping code injection detection due to error in file: {}", inputFile.filename());
        }
    }

    /**
     * Detect path traversal vulnerabilities.
     */
    public void detectPathTraversal(SensorContext context, InputFile inputFile, String content) {
        try {
            Matcher matcher = PATH_TRAVERSAL_PATTERN.matcher(content);

            while (matcher.find()) {
                int lineNumber = calculateLineNumber(content, matcher.start());
                reportIssue(context, inputFile, lineNumber, MathematicaRulesDefinition.PATH_TRAVERSAL_KEY,
                    "Validate and sanitize this file path to prevent path traversal attacks.");
            }
        } catch (Exception e) {
            LOG.warn("Skipping path traversal detection due to error in file: {}", inputFile.filename());
        }
    }

    /**
     * Detect weak cryptographic algorithms.
     */
    public void detectWeakCryptography(SensorContext context, InputFile inputFile, String content) {
        try {
            Matcher matcher = WEAK_CRYPTO_PATTERN.matcher(content);

            while (matcher.find()) {
                int lineNumber = calculateLineNumber(content, matcher.start());
                String match = matcher.group();

                String message;
                if (match.contains("MD5") || match.contains("SHA1") || match.contains("SHA-1")) {
                    message = "Use a stronger hash algorithm (SHA256, SHA512) instead of MD5/SHA1.";
                } else {
                    message = "Use RandomInteger instead of Random for security-sensitive operations.";
                }

                reportIssue(context, inputFile, lineNumber, MathematicaRulesDefinition.WEAK_CRYPTOGRAPHY_KEY, message);
            }
        } catch (Exception e) {
            LOG.warn("Skipping weak cryptography detection due to error in file: {}", inputFile.filename());
        }
    }

    /**
     * Detect SSRF vulnerabilities.
     */
    public void detectSsrf(SensorContext context, InputFile inputFile, String content) {
        try {
            Matcher matcher = SSRF_PATTERN.matcher(content);

            while (matcher.find()) {
                int lineNumber = calculateLineNumber(content, matcher.start());
                reportIssue(context, inputFile, lineNumber, MathematicaRulesDefinition.SSRF_KEY,
                    "Validate and sanitize URLs to prevent Server-Side Request Forgery attacks.");
            }
        } catch (Exception e) {
            LOG.warn("Skipping SSRF detection due to error in file: {}", inputFile.filename());
        }
    }

    /**
     * Detect insecure deserialization.
     */
    public void detectInsecureDeserialization(SensorContext context, InputFile inputFile, String content) {
        try {
            Matcher matcher = INSECURE_DESERIALIZATION_PATTERN.matcher(content);

            while (matcher.find()) {
                int lineNumber = calculateLineNumber(content, matcher.start());
                String match = matcher.group();

                String message;
                if (match.contains("MX") || match.contains("WDX")) {
                    message = "Avoid importing MX/WDX files from untrusted sources. Use safe formats like JSON or CSV.";
                } else {
                    message = "Avoid loading code from untrusted sources with Get[]. Validate file paths and check integrity.";
                }

                reportIssue(context, inputFile, lineNumber, MathematicaRulesDefinition.INSECURE_DESERIALIZATION_KEY, message);
            }
        } catch (Exception e) {
            LOG.warn("Skipping insecure deserialization detection due to error in file: {}", inputFile.filename());
        }
    }

    /**
     * Detect unsafe Symbol[] or ToExpression with user input.
     */
    public void detectUnsafeSymbol(SensorContext context, InputFile inputFile, String content) {
        try {
            Matcher matcher = SYMBOL_PATTERN.matcher(content);
            while (matcher.find()) {
                int lineNumber = calculateLineNumber(content, matcher.start());
                reportIssue(context, inputFile, lineNumber, MathematicaRulesDefinition.UNSAFE_SYMBOL_KEY,
                    "Using Symbol[] or ToExpression with user input allows code injection. Use whitelist instead.");
            }
        } catch (Exception e) {
            LOG.warn("Skipping unsafe symbol detection due to error in file: {}", inputFile.filename());
        }
    }

    /**
     * Detect XXE vulnerabilities in XML imports.
     */
    public void detectXXE(SensorContext context, InputFile inputFile, String content) {
        try {
            Matcher matcher = XML_IMPORT_PATTERN.matcher(content);
            while (matcher.find()) {
                String match = matcher.group();
                if (!match.contains("ProcessDTD")) {
                    int lineNumber = calculateLineNumber(content, matcher.start());
                    reportIssue(context, inputFile, lineNumber, MathematicaRulesDefinition.XXE_KEY,
                        "XML import without ProcessDTD->False is vulnerable to XXE attacks.");
                }
            }
        } catch (Exception e) {
            LOG.warn("Skipping XXE detection due to error in file: {}", inputFile.filename());
        }
    }

    /**
     * Detect missing sanitization on dangerous functions.
     */
    public void detectMissingSanitization(SensorContext context, InputFile inputFile, String content) {
        try {
            Matcher matcher = DANGEROUS_FUNCTIONS_PATTERN.matcher(content);
            while (matcher.find()) {
                int lineNumber = calculateLineNumber(content, matcher.start());
                reportIssue(context, inputFile, lineNumber, MathematicaRulesDefinition.MISSING_SANITIZATION_KEY,
                    "Dangerous function should only accept validated input. Verify path/input is sanitized.");
            }
        } catch (Exception e) {
            LOG.warn("Skipping missing sanitization detection due to error in file: {}", inputFile.filename());
        }
    }

    /**
     * Detect insecure random for security tokens.
     */
    public void detectInsecureRandomExpanded(SensorContext context, InputFile inputFile, String content) {
        try {
            Matcher matcher = RANDOM_CHOICE_PATTERN.matcher(content);
            while (matcher.find()) {
                int lineStart = content.lastIndexOf('\n', matcher.start()) + 1;
                int lineEnd = content.indexOf('\n', matcher.start());
                if (lineEnd == -1) lineEnd = content.length();
                String line = content.substring(lineStart, lineEnd);

                if (line.matches(".*(?:token|password|key|secret|session).*")) {
                    int lineNumber = calculateLineNumber(content, matcher.start());
                    reportIssue(context, inputFile, lineNumber, MathematicaRulesDefinition.INSECURE_RANDOM_EXPANDED_KEY,
                        "Using Random/RandomChoice for security tokens is insecure. Use RandomInteger instead.");
                }
            }
        } catch (Exception e) {
            LOG.warn("Skipping insecure random detection due to error in file: {}", inputFile.filename());
        }
    }

    /**
     * Detect unsafe CloudDeploy without permissions check.
     */
    public void detectUnsafeCloudDeploy(SensorContext context, InputFile inputFile, String content) {
        try {
            Matcher matcher = CLOUD_DEPLOY_PATTERN.matcher(content);
            while (matcher.find()) {
                String match = matcher.group();
                if (!match.contains("Permissions")) {
                    int lineNumber = calculateLineNumber(content, matcher.start());
                    reportIssue(context, inputFile, lineNumber, MathematicaRulesDefinition.UNSAFE_CLOUD_DEPLOY_KEY,
                        "CloudDeploy without explicit Permissions exposes code publicly. Specify Permissions option.");
                }
            }
        } catch (Exception e) {
            LOG.warn("Skipping unsafe CloudDeploy detection due to error in file: {}", inputFile.filename());
        }
    }

    /**
     * Detect Dynamic injection vulnerabilities.
     */
    public void detectDynamicInjection(SensorContext context, InputFile inputFile, String content) {
        try {
            Matcher matcher = DYNAMIC_TOEXPRESSION_PATTERN.matcher(content);
            while (matcher.find()) {
                int lineNumber = calculateLineNumber(content, matcher.start());
                reportIssue(context, inputFile, lineNumber, MathematicaRulesDefinition.DYNAMIC_INJECTION_KEY,
                    "Dynamic[] with ToExpression/Symbol allows code injection. Validate and whitelist inputs.");
            }
        } catch (Exception e) {
            LOG.warn("Skipping Dynamic injection detection due to error in file: {}", inputFile.filename());
        }
    }
}
