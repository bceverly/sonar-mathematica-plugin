package org.sonar.plugins.mathematica.rules;

import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.sonar.api.batch.fs.InputFile;
import org.sonar.api.batch.sensor.SensorContext;

/**
 * Detector for Vulnerability/Security rules (14 rules total).
 * Handles injection attacks, insecure APIs, and security weaknesses.
 */
public class VulnerabilityDetector extends BaseDetector {

    // ===== PATTERNS FOR VULNERABILITY DETECTION =====

    private static final Pattern HARDCODED_CREDENTIAL_PATTERN = Pattern.compile(
        "(?i)(password|passwd|pwd|secret|apikey|api_key|token|auth|credential|private_key|"
        + "access_key|secret_key|aws_access_key_id|aws_secret_access_key)\\s*=\\s*\"([^\"]{8,})\"",
        Pattern.CASE_INSENSITIVE
    );
    private static final Pattern COMMAND_INJECTION_PATTERN = Pattern.compile(
        "(?:Run|RunProcess|Import)\\s*\\[\\s*(?:\"[^\"]*\"\\s*<>|\\{\"sh\"|\\{\"bash\"|\"!\"\\s*<>)"
    );
    private static final Pattern SQL_INJECTION_PATTERN = Pattern.compile(
        "(?:SQLExecute|SQLSelect|SQLInsert|SQLUpdate|SQLDelete)\\s*\\[[^,]{0,200},\\s*\"[^\"]*\"\\s*<>"
    );
    private static final Pattern CODE_INJECTION_PATTERN = Pattern.compile(
        "(?:ToExpression|Evaluate)\\s*\\[\\s*(?!\")"
    );
    private static final Pattern PATH_TRAVERSAL_PATTERN = Pattern.compile(
        "(?:Import|Export|Get|Put|OpenRead|OpenWrite|OpenAppend)\\s*\\[[^\\]]{0,200}<>[^\\]]{0,200}\\]"
    );
    private static final Pattern WEAK_CRYPTO_PATTERN = Pattern.compile(
        "(?:Hash\\s*\\[[^,]{1,200},\\s*\"(?:MD5|SHA1|SHA-1)\")|(?:Random\\s*\\[)"
    );
    private static final Pattern SSRF_PATTERN = Pattern.compile(
        "(?:URLFetch|URLRead|URLExecute|ServiceExecute)\\s*\\[[^\\]]{0,200}<>|"         + "Import\\s*\\[\\s*(?:\"https?://\"|\"http://\")\\s*<>"
    );
    private static final Pattern INSECURE_DESERIALIZATION_PATTERN = Pattern.compile(
        "(?:Import\\s*\\[[^,]{1,200},\\s*\"(?:MX|WDX)\")|"         + "(?:Get\\s*\\[(?:[^\\]]{0,200}<>|\"https?://))"
    );

    // Phase 2 Vulnerability patterns
    private static final Pattern SYMBOL_PATTERN = Pattern.compile("Symbol\\s*\\[|ToExpression\\s*\\[");
    private static final Pattern XML_IMPORT_PATTERN = Pattern.compile("Import\\s*\\[[^,]{1,200},\\s*\"XML\"");
    private static final Pattern DANGEROUS_FUNCTIONS_PATTERN = Pattern.compile(
        "(?:DeleteFile|DeleteDirectory|RenameFile|SystemOpen)\\s*\\["
    );

    // Phase 4 Vulnerability patterns (optimized - pre-compiled for performance)
    private static final Pattern TOEXPRESSION_VAR_PATTERN = Pattern.compile("ToExpression\\s*\\[\\s*([a-zA-Z]\\w*)");
    private static final Pattern RUNPROCESS_PATTERN = Pattern.compile("(?:RunProcess|Run)\\s*\\[");
    private static final Pattern CLOUD_DEPLOY_API_PATTERN = Pattern.compile(
        "CloudDeploy\\s*\\[\\s*(?:APIFunction|FormFunction)\\s*\\[");
    private static final Pattern API_KEY_PATTERN = Pattern.compile(
            "(?:\"APIKey\"|\"apikey\"|\"api_key\"|\"token\"|\"secret\")\\s*->?\\s*\"([a-zA-Z0-9_\\-]{20,})\"");
    private static final Pattern NEEDS_GET_VAR_PATTERN = Pattern.compile("(?:Needs|Get)\\s*\\[\\s*([a-zA-Z]\\w*)");
    private static final Pattern FORMFUNCTION_PATTERN = Pattern.compile("FormFunction\\s*\\[\\s*\\{([^}]{1,500})\\}");
    private static final Pattern RANDOM_CHOICE_PATTERN = Pattern.compile("RandomChoice\\s*\\[|Random\\s*\\[");

    // Phase 3 Security patterns
    private static final Pattern CLOUD_DEPLOY_PATTERN = Pattern.compile("CloudDeploy\\s*\\[[^,\\]]{1,200}\\s*\\]");
    private static final Pattern DYNAMIC_TOEXPRESSION_PATTERN = Pattern.compile(
        "Dynamic\\s*\\[[^\\]]{0,200}(?:ToExpression|Symbol)\\s*\\["
    );

    // Performance limit: Skip vulnerability detection on very large files
    private static final int MAX_FILE_SIZE_FOR_VULN_DETECTION = 50_000; // lines

    /**
     * Check if file is too large for vulnerability detection.
     * Very large files can cause performance issues with regex matching.
     */
    private boolean shouldSkipLargeFile(String content, String filename) {
        int lineCount = 1;
        for (int i = 0; i < content.length(); i++) {
            if (content.charAt(i) == '\n') {
                lineCount++;
                if (lineCount > MAX_FILE_SIZE_FOR_VULN_DETECTION) {
                    LOG.info("Skipping vulnerability detection for large file (>{}K lines): {}",
                        MAX_FILE_SIZE_FOR_VULN_DETECTION / 1000, filename);
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Detect hardcoded credentials.
     */
    public void detectHardcodedCredentials(SensorContext context, InputFile inputFile, String content) {
        try {
            Matcher matcher = HARDCODED_CREDENTIAL_PATTERN.matcher(content);

            while (matcher.find()) {
                String variableName = matcher.group(1);
                String value = matcher.group(2);

                // Skip placeholders
                if (isPlaceholderValue(value)) {
                    continue;
                }

                int lineNumber = calculateLineNumber(content, matcher.start());
                reportIssue(context, inputFile, lineNumber, MathematicaRulesDefinition.HARDCODED_CREDENTIALS_KEY,
                    String.format("Remove this hard-coded credential '%s'.", variableName));
            }
        } catch (Exception e) {
            LOG.warn("Skipping hardcoded credential detection due to error in file: {}", inputFile.filename());
        }
    }

    /**
     * Check if a value looks like a placeholder.
     */
    private boolean isPlaceholderValue(String value) {
        String lower = value.toLowerCase();

        if (lower.contains("example") || lower.contains("placeholder") || lower.contains("your_")) {
            return true;
        }
        if (lower.contains("xxx") || lower.equals("password") || lower.equals("secret")) {
            return true;
        }

        return value.matches("^[*]+$") || value.matches("^[x]+$");
    }

    /**
     * Detect command injection vulnerabilities.
     */
    public void detectCommandInjection(SensorContext context, InputFile inputFile, String content) {
        try {
            Matcher matcher = COMMAND_INJECTION_PATTERN.matcher(content);

            while (matcher.find()) {
                int lineNumber = calculateLineNumber(content, matcher.start());
                reportIssue(context, inputFile, lineNumber, MathematicaRulesDefinition.COMMAND_INJECTION_KEY,
                    "Make sure that executing this OS command is safe.");
            }
        } catch (Exception e) {
            LOG.warn("Skipping command injection detection due to error in file: {}", inputFile.filename());
        }
    }

    /**
     * Detect SQL injection vulnerabilities.
     */
    public void detectSqlInjection(SensorContext context, InputFile inputFile, String content) {
        try {
            Matcher matcher = SQL_INJECTION_PATTERN.matcher(content);

            while (matcher.find()) {
                int lineNumber = calculateLineNumber(content, matcher.start());
                reportIssue(context, inputFile, lineNumber, MathematicaRulesDefinition.SQL_INJECTION_KEY,
                    "Use parameterized queries to prevent SQL injection.");
            }
        } catch (Exception e) {
            LOG.warn("Skipping SQL injection detection due to error in file: {}", inputFile.filename());
        }
    }

    /**
     * Detect code injection via ToExpression.
     */
    public void detectCodeInjection(SensorContext context, InputFile inputFile, String content) {
        try {
            Matcher matcher = CODE_INJECTION_PATTERN.matcher(content);

            while (matcher.find()) {
                int lineNumber = calculateLineNumber(content, matcher.start());
                reportIssue(context, inputFile, lineNumber, MathematicaRulesDefinition.CODE_INJECTION_KEY,
                    "Make sure that evaluating this expression is safe.");
            }
        } catch (Exception e) {
            LOG.warn("Skipping code injection detection due to error in file: {}", inputFile.filename());
        }
    }

    /**
     * Detect path traversal vulnerabilities.
     */
    public void detectPathTraversal(SensorContext context, InputFile inputFile, String content) {
        try {
            Matcher matcher = PATH_TRAVERSAL_PATTERN.matcher(content);

            while (matcher.find()) {
                int lineNumber = calculateLineNumber(content, matcher.start());
                reportIssue(context, inputFile, lineNumber, MathematicaRulesDefinition.PATH_TRAVERSAL_KEY,
                    "Validate and sanitize this file path to prevent path traversal attacks.");
            }
        } catch (Exception e) {
            LOG.warn("Skipping path traversal detection due to error in file: {}", inputFile.filename());
        }
    }

    /**
     * Detect weak cryptographic algorithms.
     */
    public void detectWeakCryptography(SensorContext context, InputFile inputFile, String content) {
        try {
            Matcher matcher = WEAK_CRYPTO_PATTERN.matcher(content);

            while (matcher.find()) {
                int lineNumber = calculateLineNumber(content, matcher.start());
                String match = matcher.group();

                String message;
                if (match.contains("MD5") || match.contains("SHA1") || match.contains("SHA-1")) {
                    message = "Use a stronger hash algorithm (SHA256, SHA512) instead of MD5/SHA1.";
                } else {
                    message = "Use RandomInteger instead of Random for security-sensitive operations.";
                }

                reportIssue(context, inputFile, lineNumber, MathematicaRulesDefinition.WEAK_CRYPTOGRAPHY_KEY, message);
            }
        } catch (Exception e) {
            LOG.warn("Skipping weak cryptography detection due to error in file: {}", inputFile.filename());
        }
    }

    /**
     * Detect SSRF vulnerabilities.
     */
    public void detectSsrf(SensorContext context, InputFile inputFile, String content) {
        try {
            Matcher matcher = SSRF_PATTERN.matcher(content);

            while (matcher.find()) {
                int lineNumber = calculateLineNumber(content, matcher.start());
                reportIssue(context, inputFile, lineNumber, MathematicaRulesDefinition.SSRF_KEY,
                    "Validate and sanitize URLs to prevent Server-Side Request Forgery attacks.");
            }
        } catch (Exception e) {
            LOG.warn("Skipping SSRF detection due to error in file: {}", inputFile.filename());
        }
    }

    /**
     * Detect insecure deserialization.
     */
    public void detectInsecureDeserialization(SensorContext context, InputFile inputFile, String content) {
        try {
            Matcher matcher = INSECURE_DESERIALIZATION_PATTERN.matcher(content);

            while (matcher.find()) {
                int lineNumber = calculateLineNumber(content, matcher.start());
                String match = matcher.group();

                String message;
                if (match.contains("MX") || match.contains("WDX")) {
                    message = "Avoid importing MX/WDX files from untrusted sources. Use safe formats like JSON or CSV.";
                } else {
                    message = "Avoid loading code from untrusted sources with Get[]. Validate file paths and check integrity.";
                }

                reportIssue(context, inputFile, lineNumber, MathematicaRulesDefinition.INSECURE_DESERIALIZATION_KEY, message);
            }
        } catch (Exception e) {
            LOG.warn("Skipping insecure deserialization detection due to error in file: {}", inputFile.filename());
        }
    }

    /**
     * Detect unsafe Symbol[] or ToExpression with user input.
     */
    public void detectUnsafeSymbol(SensorContext context, InputFile inputFile, String content) {
        try {
            Matcher matcher = SYMBOL_PATTERN.matcher(content);
            while (matcher.find()) {
                int lineNumber = calculateLineNumber(content, matcher.start());
                reportIssue(context, inputFile, lineNumber, MathematicaRulesDefinition.UNSAFE_SYMBOL_KEY,
                    "Using Symbol[] or ToExpression with user input allows code injection. Use whitelist instead.");
            }
        } catch (Exception e) {
            LOG.warn("Skipping unsafe symbol detection due to error in file: {}", inputFile.filename());
        }
    }

    /**
     * Detect XXE vulnerabilities in XML imports.
     */
    public void detectXXE(SensorContext context, InputFile inputFile, String content) {
        try {
            Matcher matcher = XML_IMPORT_PATTERN.matcher(content);
            while (matcher.find()) {
                String match = matcher.group();
                if (!match.contains("ProcessDTD")) {
                    int lineNumber = calculateLineNumber(content, matcher.start());
                    reportIssue(context, inputFile, lineNumber, MathematicaRulesDefinition.XXE_KEY,
                        "XML import without ProcessDTD->False is vulnerable to XXE attacks.");
                }
            }
        } catch (Exception e) {
            LOG.warn("Skipping XXE detection due to error in file: {}", inputFile.filename());
        }
    }

    /**
     * Detect missing sanitization on dangerous functions.
     */
    public void detectMissingSanitization(SensorContext context, InputFile inputFile, String content) {
        try {
            Matcher matcher = DANGEROUS_FUNCTIONS_PATTERN.matcher(content);
            while (matcher.find()) {
                int lineNumber = calculateLineNumber(content, matcher.start());
                reportIssue(context, inputFile, lineNumber, MathematicaRulesDefinition.MISSING_SANITIZATION_KEY,
                    "Dangerous function should only accept validated input. Verify path/input is sanitized.");
            }
        } catch (Exception e) {
            LOG.warn("Skipping missing sanitization detection due to error in file: {}", inputFile.filename());
        }
    }

    /**
     * Detect insecure random for security tokens.
     */
    public void detectInsecureRandomExpanded(SensorContext context, InputFile inputFile, String content) {
        try {
            Matcher matcher = RANDOM_CHOICE_PATTERN.matcher(content);
            while (matcher.find()) {
                int lineStart = content.lastIndexOf('\n', matcher.start()) + 1;
                int lineEnd = content.indexOf('\n', matcher.start());
                if (lineEnd == -1) {
                    lineEnd = content.length();
                }
                String line = content.substring(lineStart, lineEnd);

                if (line.matches(".*(?:token|password|key|secret|session).*")) {
                    int lineNumber = calculateLineNumber(content, matcher.start());
                    reportIssue(context, inputFile, lineNumber, MathematicaRulesDefinition.INSECURE_RANDOM_EXPANDED_KEY,
                        "Using Random/RandomChoice for security tokens is insecure. Use RandomInteger instead.");
                }
            }
        } catch (Exception e) {
            LOG.warn("Skipping insecure random detection due to error in file: {}", inputFile.filename());
        }
    }

    /**
     * Detect unsafe CloudDeploy without permissions check.
     */
    public void detectUnsafeCloudDeploy(SensorContext context, InputFile inputFile, String content) {
        try {
            Matcher matcher = CLOUD_DEPLOY_PATTERN.matcher(content);
            while (matcher.find()) {
                String match = matcher.group();
                if (!match.contains("Permissions")) {
                    int lineNumber = calculateLineNumber(content, matcher.start());
                    reportIssue(context, inputFile, lineNumber, MathematicaRulesDefinition.UNSAFE_CLOUD_DEPLOY_KEY,
                        "CloudDeploy without explicit Permissions exposes code publicly. Specify Permissions option.");
                }
            }
        } catch (Exception e) {
            LOG.warn("Skipping unsafe CloudDeploy detection due to error in file: {}", inputFile.filename());
        }
    }

    /**
     * Detect Dynamic injection vulnerabilities.
     */
    public void detectDynamicInjection(SensorContext context, InputFile inputFile, String content) {
        try {
            Matcher matcher = DYNAMIC_TOEXPRESSION_PATTERN.matcher(content);
            while (matcher.find()) {
                int lineNumber = calculateLineNumber(content, matcher.start());
                reportIssue(context, inputFile, lineNumber, MathematicaRulesDefinition.DYNAMIC_INJECTION_KEY,
                    "Dynamic[] with ToExpression/Symbol allows code injection. Validate and whitelist inputs.");
            }
        } catch (Exception e) {
            LOG.warn("Skipping Dynamic injection detection due to error in file: {}", inputFile.filename());
        }
    }

    // ===== PHASE 4: NEW VULNERABILITY DETECTORS (7 methods) =====

    /**
     * Detect ToExpression on external/user input (critical vulnerability).
     */
    public void detectToExpressionOnInput(SensorContext context, InputFile inputFile, String content) {
        try {
            // Find ToExpression with variables that might be user input
            Matcher matcher = TOEXPRESSION_VAR_PATTERN.matcher(content);

            while (matcher.find()) {
                String varName = matcher.group(1);
                // Check if variable might be user input (heuristic: from Import, Input, URLFetch, etc.)
                int pos = matcher.start();
                String lookback = content.substring(Math.max(0, pos - 500), pos);
                if (lookback.contains("Import[")
                    || lookback.contains("Input")
                    || lookback.contains("URLFetch")
                    || lookback.contains("APIFunction")
                    || lookback.contains("FormFunction")
                    || varName.toLowerCase().contains("input")
                    || varName.toLowerCase().contains("user")
                    || varName.toLowerCase().contains("request")) {

                    int line = calculateLineNumber(content, pos);
                    reportIssue(context, inputFile, line, MathematicaRulesDefinition.TOEXPRESSION_ON_INPUT_KEY,
                        "CRITICAL: ToExpression on external input enables arbitrary code execution. Use Interpreter[] instead.");
                }
            }
        } catch (Exception e) {
            LOG.warn("Skipping ToExpression on input detection due to error in file: {}", inputFile.filename());
        }
    }

    /**
     * Detect unsanitized RunProcess/Run with user input.
     */
    public void detectUnsanitizedRunProcess(SensorContext context, InputFile inputFile, String content) {
        try {
            // Find RunProcess or Run with user-controlled input
            Matcher matcher = RUNPROCESS_PATTERN.matcher(content);

            while (matcher.find()) {
                int pos = matcher.start();
                String snippet = content.substring(pos, Math.min(pos + 200, content.length()));
                // Check if contains variables that might be user input
                String lookback = content.substring(Math.max(0, pos - 300), pos);
                if (lookback.contains("Import[")
                    || lookback.contains("Input")
                    || lookback.contains("URLFetch")
                    || lookback.contains("APIFunction")
                    || lookback.contains("FormFunction")
                    || snippet.matches(".*\\b(?:input|user|request)\\w*.*")) {

                    int line = calculateLineNumber(content, pos);
                    reportIssue(context, inputFile, line, MathematicaRulesDefinition.UNSANITIZED_RUNPROCESS_KEY,
                        "CRITICAL: RunProcess/Run with user input enables command injection. Validate and sanitize inputs.");
                }
            }
        } catch (Exception e) {
            LOG.warn("Skipping unsanitized RunProcess detection due to error in file: {}", inputFile.filename());
        }
    }

    /**
     * Detect missing cloud authentication.
     */
    public void detectMissingCloudAuth(SensorContext context, InputFile inputFile, String content) {
        try {
            // Find CloudDeploy with APIFunction/FormFunction without Permissions
            Matcher matcher = CLOUD_DEPLOY_API_PATTERN.matcher(content);

            while (matcher.find()) {
                int pos = matcher.start();
                String snippet = content.substring(pos, Math.min(pos + 500, content.length()));
                if (!snippet.contains("Permissions")) {
                    int line = calculateLineNumber(content, pos);
                    reportIssue(context, inputFile, line, MathematicaRulesDefinition.MISSING_CLOUD_AUTH_KEY,
                        "CRITICAL: Cloud function without Permissions is publicly accessible. Add Permissions -> \"Private\" or specific users.");
                }
            }
        } catch (Exception e) {
            LOG.warn("Skipping missing cloud auth detection due to error in file: {}", inputFile.filename());
        }
    }

    /**
     * Detect hardcoded API keys and tokens.
     */
    public void detectHardcodedApiKeys(SensorContext context, InputFile inputFile, String content) {
        try {
            // Find API key patterns (sk-, api_, etc.) in strings
            Matcher matcher = API_KEY_PATTERN.matcher(content);

            while (matcher.find()) {
                String keyValue = matcher.group(1);
                // Check if it's not a variable reference
                if (!keyValue.startsWith("$") && !keyValue.contains("Credential")) {
                    int line = calculateLineNumber(content, matcher.start());
                    reportIssue(context, inputFile, line, MathematicaRulesDefinition.HARDCODED_API_KEYS_KEY,
                        "CRITICAL: Hardcoded API key/token found. Use SystemCredential[] instead.");
                }
            }
        } catch (Exception e) {
            LOG.warn("Skipping hardcoded API keys detection due to error in file: {}", inputFile.filename());
        }
    }

    /**
     * Detect Needs/Get loading from untrusted paths.
     */
    public void detectNeedsGetUntrusted(SensorContext context, InputFile inputFile, String content) {
        try {
            // Find Needs or Get with variables (potential path injection)
            Matcher matcher = NEEDS_GET_VAR_PATTERN.matcher(content);

            while (matcher.find()) {
                String varName = matcher.group(1);
                int pos = matcher.start();
                String lookback = content.substring(Math.max(0, pos - 300), pos);

                // Check if variable comes from user input
                if (lookback.contains("Import[")
                    || lookback.contains("Input")
                    || lookback.contains("URLFetch")
                    || varName.toLowerCase().contains("input")
                    || varName.toLowerCase().contains("user")
                    || varName.toLowerCase().contains("path")) {

                    int line = calculateLineNumber(content, pos);
                    reportIssue(context, inputFile, line, MathematicaRulesDefinition.NEEDS_GET_UNTRUSTED_KEY,
                        "CRITICAL: Loading package from user-controlled path enables code execution. Validate against whitelist.");
                }
            }
        } catch (Exception e) {
            LOG.warn("Skipping Needs/Get untrusted detection due to error in file: {}", inputFile.filename());
        }
    }

    /**
     * Detect exposing sensitive system information in cloud functions.
     */
    public void detectExposingSensitiveData(SensorContext context, InputFile inputFile, String content) {
        try {
            // Find CloudDeploy/APIFunction returning system variables
            Matcher matcher = CLOUD_DEPLOY_API_PATTERN.matcher(content);

            while (matcher.find()) {
                int pos = matcher.start();
                String snippet = content.substring(pos, Math.min(pos + 400, content.length()));

                // Check for sensitive system variables
                if (snippet.contains("$UserName")
                    || snippet.contains("$MachineName")
                    || snippet.contains("$HomeDirectory")
                    || snippet.contains("$InstallationDirectory")
                    || snippet.contains("SystemCredential")
                    || snippet.contains("password")
                    || snippet.contains("$ProcessID")) {

                    int line = calculateLineNumber(content, pos);
                    reportIssue(context, inputFile, line, MathematicaRulesDefinition.EXPOSING_SENSITIVE_DATA_KEY,
                        "Cloud function exposes sensitive system information ($UserName, credentials, etc.).");
                }
            }
        } catch (Exception e) {
            LOG.warn("Skipping exposing sensitive data detection due to error in file: {}", inputFile.filename());
        }
    }

    /**
     * Detect missing FormFunction input validation.
     */
    public void detectMissingFormFunctionValidation(SensorContext context, InputFile inputFile, String content) {
        try {
            // Find FormFunction without Restricted or validation
            Matcher matcher = FORMFUNCTION_PATTERN.matcher(content);

            while (matcher.find()) {
                String formFields = matcher.group(1);
                // Check if fields use Restricted or have type constraints
                if (!formFields.contains("Restricted[")
                    && !formFields.contains("_Integer")
                    && !formFields.contains("_Real")
                    && !formFields.contains("_String")
                    && !formFields.contains("Interpreter[")) {

                    int line = calculateLineNumber(content, matcher.start());
                    reportIssue(context, inputFile, line, MathematicaRulesDefinition.MISSING_FORMFUNCTION_VALIDATION_KEY,
                        "FormFunction inputs lack validation. Use Restricted[], Interpreter[], or type constraints.");
                }
            }
        } catch (Exception e) {
            LOG.warn("Skipping missing FormFunction validation detection due to error in file: {}", inputFile.filename());
        }
    }
}
