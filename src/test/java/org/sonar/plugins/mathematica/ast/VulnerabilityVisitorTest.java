package org.sonar.plugins.mathematica.ast;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.sonar.api.batch.fs.InputFile;
import org.sonar.plugins.mathematica.rules.MathematicaRulesDefinition;
import org.sonar.plugins.mathematica.rules.MathematicaRulesSensor;

import java.util.Arrays;
import java.util.Collections;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.atLeastOnce;

class VulnerabilityVisitorTest {

    private VulnerabilityVisitor visitor;
    private InputFile inputFile;
    private MathematicaRulesSensor sensor;

    @BeforeEach
    void setUp() {
        inputFile = mock(InputFile.class);
        sensor = mock(MathematicaRulesSensor.class);
        visitor = new VulnerabilityVisitor(inputFile, sensor);
    }

    @Test
    void testCommandInjectionWithRun() {
        // Run[cmd] where cmd is a variable - vulnerable
        IdentifierNode cmdVar = new IdentifierNode("cmd", 1, 1, 1, 4);
        FunctionCallNode runCall = new FunctionCallNode("Run", Collections.singletonList(cmdVar), 1, 1, 1, 10);

        visitor.visit(runCall);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.COMMAND_INJECTION_KEY), any(String.class));
    }

    @Test
    void testCommandInjectionWithRunProcess() {
        // RunProcess["ls " <> input] - vulnerable due to concatenation
        LiteralNode lsCmd = new LiteralNode("ls ", LiteralNode.LiteralType.STRING, 1, 1, 1, 5);
        IdentifierNode input = new IdentifierNode("input", 1, 10, 1, 15);
        OperatorNode concat = new OperatorNode(OperatorNode.OperatorType.ADD,
            lsCmd, input, "<>", 1, 1, 1, 15);
        FunctionCallNode runProcess = new FunctionCallNode("RunProcess",
            Collections.singletonList(concat), 1, 1, 1, 25);

        visitor.visit(runProcess);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.COMMAND_INJECTION_KEY), any(String.class));
    }

    @Test
    void testCommandInjectionSafe() {
        // Run["ls"] - safe, literal command
        LiteralNode lsCmd = new LiteralNode("ls", LiteralNode.LiteralType.STRING, 1, 1, 1, 4);
        FunctionCallNode runCall = new FunctionCallNode("Run", Collections.singletonList(lsCmd), 1, 1, 1, 10);

        visitor.visit(runCall);

        verify(sensor, never()).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.COMMAND_INJECTION_KEY), any(String.class));
    }

    @Test
    void testSqlInjectionWithConcatenation() {
        // SQLExecute[conn, "SELECT * FROM users WHERE name = '" <> userName <> "'"]
        LiteralNode query1 = new LiteralNode("SELECT * FROM users WHERE name = '",
            LiteralNode.LiteralType.STRING, 1, 1, 1, 10);
        IdentifierNode userName = new IdentifierNode("userName", 1, 15, 1, 23);
        LiteralNode query2 = new LiteralNode("'", LiteralNode.LiteralType.STRING, 1, 28, 1, 29);
        OperatorNode concat1 = new OperatorNode(OperatorNode.OperatorType.ADD,
            query1, userName, "<>", 1, 1, 1, 23);
        OperatorNode concat2 = new OperatorNode(OperatorNode.OperatorType.ADD,
            concat1, query2, "<>", 1, 1, 1, 29);

        FunctionCallNode sqlExecute = new FunctionCallNode("SQLExecute",
            Arrays.asList(new IdentifierNode("conn", 1, 1, 1, 5), concat2), 1, 1, 1, 40);

        visitor.visit(sqlExecute);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.SQL_INJECTION_KEY), any(String.class));
    }

    @Test
    void testCodeInjectionWithToExpression() {
        // ToExpression[userInput] - vulnerable
        IdentifierNode userInput = new IdentifierNode("userInput", 1, 1, 1, 10);
        FunctionCallNode toExpr = new FunctionCallNode("ToExpression",
            Collections.singletonList(userInput), 1, 1, 1, 25);

        visitor.visit(toExpr);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.CODE_INJECTION_KEY), any(String.class));
    }

    @Test
    void testCodeInjectionSafe() {
        // ToExpression["x + 1"] - safe, literal expression
        LiteralNode expr = new LiteralNode("x + 1", LiteralNode.LiteralType.STRING, 1, 1, 1, 7);
        FunctionCallNode toExpr = new FunctionCallNode("ToExpression",
            Collections.singletonList(expr), 1, 1, 1, 25);

        visitor.visit(toExpr);

        verify(sensor, never()).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.CODE_INJECTION_KEY), any(String.class));
    }

    @Test
    void testPathTraversalWithImport() {
        // Import[basePath <> userFile] - vulnerable
        IdentifierNode basePath = new IdentifierNode("basePath", 1, 1, 1, 9);
        IdentifierNode userFile = new IdentifierNode("userFile", 1, 15, 1, 23);
        OperatorNode concat = new OperatorNode(OperatorNode.OperatorType.ADD,
            basePath, userFile, "<>", 1, 1, 1, 23);
        FunctionCallNode importCall = new FunctionCallNode("Import",
            Collections.singletonList(concat), 1, 1, 1, 30);

        visitor.visit(importCall);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.PATH_TRAVERSAL_KEY), any(String.class));
    }

    @Test
    void testWeakCryptographyMD5() {
        // Hash[data, "MD5"] - weak algorithm
        IdentifierNode data = new IdentifierNode("data", 1, 1, 1, 5);
        LiteralNode md5 = new LiteralNode("MD5", LiteralNode.LiteralType.STRING, 1, 7, 1, 12);
        FunctionCallNode hashCall = new FunctionCallNode("Hash",
            Arrays.asList(data, md5), 1, 1, 1, 18);

        visitor.visit(hashCall);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.WEAK_CRYPTOGRAPHY_KEY), any(String.class));
    }

    @Test
    void testWeakCryptographySHA1() {
        // Hash[data, "SHA1"] - weak algorithm
        IdentifierNode data = new IdentifierNode("data", 1, 1, 1, 5);
        LiteralNode sha1 = new LiteralNode("SHA1", LiteralNode.LiteralType.STRING, 1, 7, 1, 13);
        FunctionCallNode hashCall = new FunctionCallNode("Hash",
            Arrays.asList(data, sha1), 1, 1, 1, 19);

        visitor.visit(hashCall);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.WEAK_CRYPTOGRAPHY_KEY), any(String.class));
    }

    @Test
    void testWeakCryptographyRandom() {
        // Random[] - insecure for cryptographic use
        FunctionCallNode randomCall = new FunctionCallNode("Random",
            Collections.emptyList(), 1, 1, 1, 8);

        visitor.visit(randomCall);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.WEAK_CRYPTOGRAPHY_KEY), any(String.class));
    }

    @Test
    void testSSRFWithURLFetch() {
        // URLFetch[url] where url is variable - vulnerable
        IdentifierNode url = new IdentifierNode("url", 1, 1, 1, 4);
        FunctionCallNode urlFetch = new FunctionCallNode("URLFetch",
            Collections.singletonList(url), 1, 1, 1, 15);

        visitor.visit(urlFetch);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.SSRF_KEY), any(String.class));
    }

    @Test
    void testInsecureDeserializationMX() {
        // Import[file, "MX"] - insecure format
        IdentifierNode file = new IdentifierNode("file", 1, 1, 1, 5);
        LiteralNode mx = new LiteralNode("MX", LiteralNode.LiteralType.STRING, 1, 7, 1, 11);
        FunctionCallNode importCall = new FunctionCallNode("Import",
            Arrays.asList(file, mx), 1, 1, 1, 18);

        visitor.visit(importCall);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.INSECURE_DESERIALIZATION_KEY), any(String.class));
    }

    @Test
    void testInsecureDeserializationWDX() {
        // Import[file, "WDX"] - insecure format
        IdentifierNode file = new IdentifierNode("file", 1, 1, 1, 5);
        LiteralNode wdx = new LiteralNode("WDX", LiteralNode.LiteralType.STRING, 1, 7, 1, 12);
        FunctionCallNode importCall = new FunctionCallNode("Import",
            Arrays.asList(file, wdx), 1, 1, 1, 19);

        visitor.visit(importCall);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.INSECURE_DESERIALIZATION_KEY), any(String.class));
    }

    @Test
    void testInsecureDeserializationGetWithUrl() {
        // Get["http://example.com/code.m"] - loading code from URL
        LiteralNode urlPath = new LiteralNode("http://example.com/code.m",
            LiteralNode.LiteralType.STRING, 1, 1, 1, 27);
        FunctionCallNode getCall = new FunctionCallNode("Get",
            Collections.singletonList(urlPath), 1, 1, 1, 35);

        visitor.visit(getCall);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.INSECURE_DESERIALIZATION_KEY), any(String.class));
    }

    @Test
    void testUnsafeSymbol() {
        // Symbol[varName] - allows code injection
        IdentifierNode varName = new IdentifierNode("varName", 1, 1, 1, 8);
        FunctionCallNode symbolCall = new FunctionCallNode("Symbol",
            Collections.singletonList(varName), 1, 1, 1, 17);

        visitor.visit(symbolCall);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.UNSAFE_SYMBOL_KEY), any(String.class));
    }

    @Test
    void testXXEVulnerability() {
        // Import[file, "XML"] - vulnerable to XXE
        IdentifierNode file = new IdentifierNode("file", 1, 1, 1, 5);
        LiteralNode xml = new LiteralNode("XML", LiteralNode.LiteralType.STRING, 1, 7, 1, 12);
        FunctionCallNode importCall = new FunctionCallNode("Import",
            Arrays.asList(file, xml), 1, 1, 1, 19);

        visitor.visit(importCall);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.XXE_KEY), any(String.class));
    }

    @Test
    void testMissingSanitization() {
        // DeleteFile[path] - dangerous operation
        IdentifierNode path = new IdentifierNode("path", 1, 1, 1, 5);
        FunctionCallNode deleteFile = new FunctionCallNode("DeleteFile",
            Collections.singletonList(path), 1, 1, 1, 17);

        visitor.visit(deleteFile);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.MISSING_SANITIZATION_KEY), any(String.class));
    }

    @Test
    void testInsecureRandom() {
        // Random[] for security - insecure
        FunctionCallNode randomCall = new FunctionCallNode("Random",
            Collections.emptyList(), 1, 1, 1, 8);

        visitor.visit(randomCall);

        // Should trigger INSECURE_RANDOM_EXPANDED_KEY
        verify(sensor, atLeastOnce()).queueIssue(eq(inputFile), eq(1), any(String.class), any(String.class));
    }

    @Test
    void testUnsafeCloudDeployWithoutPermissions() {
        // CloudDeploy[function] - missing Permissions
        IdentifierNode function = new IdentifierNode("myFunc", 1, 1, 1, 7);
        FunctionCallNode cloudDeploy = new FunctionCallNode("CloudDeploy",
            Collections.singletonList(function), 1, 1, 1, 20);

        visitor.visit(cloudDeploy);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.UNSAFE_CLOUD_DEPLOY_KEY), any(String.class));
    }

    @Test
    void testUnsafeCloudDeployWithPermissions() {
        // CloudDeploy[function, Permissions -> "Private"] - has Permissions
        IdentifierNode function = new IdentifierNode("myFunc", 1, 1, 1, 7);
        IdentifierNode permissions = new IdentifierNode("Permissions", 1, 10, 1, 21);
        FunctionCallNode cloudDeploy = new FunctionCallNode("CloudDeploy",
            Arrays.asList(function, permissions), 1, 1, 1, 30);

        visitor.visit(cloudDeploy);

        verify(sensor, never()).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.UNSAFE_CLOUD_DEPLOY_KEY), any(String.class));
    }

    @Test
    void testDynamicInjectionWithToExpression() {
        // Dynamic[ToExpression[input]] - vulnerable
        IdentifierNode input = new IdentifierNode("input", 1, 1, 1, 6);
        FunctionCallNode toExpr = new FunctionCallNode("ToExpression",
            Collections.singletonList(input), 1, 1, 1, 20);
        FunctionCallNode dynamic = new FunctionCallNode("Dynamic",
            Collections.singletonList(toExpr), 1, 1, 1, 28);

        visitor.visit(dynamic);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.DYNAMIC_INJECTION_KEY), any(String.class));
    }

    @Test
    void testToExpressionOnUserInput() {
        // ToExpression[userInput] where userInput is a user input variable
        IdentifierNode userInput = new IdentifierNode("userInput", 1, 1, 1, 10);
        FunctionCallNode toExpr = new FunctionCallNode("ToExpression",
            Collections.singletonList(userInput), 1, 1, 1, 25);

        visitor.visit(toExpr);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.TOEXPRESSION_ON_INPUT_KEY), any(String.class));
    }

    @Test
    void testUnsanitizedRunProcessWithUserInput() {
        // RunProcess[userInput] - critical vulnerability
        IdentifierNode userInput = new IdentifierNode("userInput", 1, 1, 1, 10);
        FunctionCallNode runProcess = new FunctionCallNode("RunProcess",
            Collections.singletonList(userInput), 1, 1, 1, 22);

        visitor.visit(runProcess);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.UNSANITIZED_RUNPROCESS_KEY), any(String.class));
    }

    @Test
    void testMissingCloudAuth() {
        // CloudDeploy[APIFunction[...]] without Permissions
        IdentifierNode handler = new IdentifierNode("handler", 1, 1, 1, 8);
        FunctionCallNode apiFunc = new FunctionCallNode("APIFunction",
            Collections.singletonList(handler), 1, 1, 1, 20);
        FunctionCallNode cloudDeploy = new FunctionCallNode("CloudDeploy",
            Collections.singletonList(apiFunc), 1, 1, 1, 33);

        visitor.visit(cloudDeploy);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.MISSING_CLOUD_AUTH_KEY), any(String.class));
    }

    @Test
    void testNeedsGetUntrusted() {
        // Needs[userPackage] - loading package from user input
        IdentifierNode userPackage = new IdentifierNode("userPackage", 1, 1, 1, 12);
        FunctionCallNode needs = new FunctionCallNode("Needs",
            Collections.singletonList(userPackage), 1, 1, 1, 19);

        visitor.visit(needs);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.NEEDS_GET_UNTRUSTED_KEY), any(String.class));
    }

    @Test
    void testExposingSensitiveData() {
        // CloudDeploy[Function[[], $UserName]] - exposes system variable
        IdentifierNode userName = new IdentifierNode("$UserName", 1, 1, 1, 10);
        FunctionCallNode cloudDeploy = new FunctionCallNode("CloudDeploy",
            Collections.singletonList(userName), 1, 1, 1, 22);

        visitor.visit(cloudDeploy);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.EXPOSING_SENSITIVE_DATA_KEY), any(String.class));
    }

    @Test
    void testMissingFormFunctionValidation() {
        // FormFunction[{field}, handler] without validation
        IdentifierNode field = new IdentifierNode("field", 1, 1, 1, 6);
        IdentifierNode handler = new IdentifierNode("handler", 1, 8, 1, 15);
        FunctionCallNode formFunc = new FunctionCallNode("FormFunction",
            Arrays.asList(field, handler), 1, 1, 1, 28);

        visitor.visit(formFunc);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.MISSING_FORMFUNCTION_VALIDATION_KEY), any(String.class));
    }

    @Test
    void testHardcodedCredentials() {
        // password = "MySecretPassword123" - hardcoded credential
        LiteralNode password = new LiteralNode("MySecretPassword123",
            LiteralNode.LiteralType.STRING, 1, 1, 1, 21);

        visitor.visit(password);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.HARDCODED_CREDENTIALS_KEY), any(String.class));
    }

    @Test
    void testHardcodedCredentialsPlaceholder() {
        // password = "your_password_here" - placeholder, should not trigger
        LiteralNode password = new LiteralNode("your_password_here",
            LiteralNode.LiteralType.STRING, 1, 1, 1, 20);

        visitor.visit(password);

        verify(sensor, never()).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.HARDCODED_CREDENTIALS_KEY), any(String.class));
    }

    @Test
    void testHardcodedApiKey() {
        // apiKey = "sk_live_51234567890abcdefghijk" - looks like API key
        LiteralNode apiKey = new LiteralNode("sk_live_51234567890abcdefghijk",
            LiteralNode.LiteralType.STRING, 1, 1, 1, 31);

        visitor.visit(apiKey);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.HARDCODED_API_KEYS_KEY), any(String.class));
    }

    @Test
    void testVisitFunctionDef() {
        // Test that FunctionDefNode visits children
        LiteralNode body = new LiteralNode(42, LiteralNode.LiteralType.INTEGER, 1, 10, 1, 12);
        FunctionDefNode funcDef = new FunctionDefNode("testFunc",
            Collections.emptyList(), body, true, 1, 1, 1, 15);

        visitor.visit(funcDef);

        // Verify no issues reported for simple function def
        verify(sensor, never()).queueIssue(any(), any(Integer.class), any(), any());
    }

    @Test
    void testVisitIdentifier() {
        // Test that IdentifierNode with system variable is tracked
        IdentifierNode userName = new IdentifierNode("$UserName", 1, 1, 1, 10);

        visitor.visit(userName);

        // Verify no issues reported for standalone identifier
        verify(sensor, never()).queueIssue(any(), any(Integer.class), any(), any());
    }

    @Test
    void testReportProfileStatsWithHighActivity() {
        // Generate high activity to trigger profiling output
        for (int i = 0; i < 100; i++) {
            IdentifierNode variable = new IdentifierNode("var" + i, 1, 1, 1, 5);
            FunctionCallNode call = new FunctionCallNode("Run",
                Collections.singletonList(variable), 1, 1, 1, 10);
            visitor.visit(call);
        }

        // Verify profiling completes without error
        visitor.reportProfileStats();
        verify(sensor, atLeastOnce()).queueIssue(any(), any(Integer.class), any(), any());
    }

    @Test
    void testTrackUserInputFunction() {
        // Input[] marks context as user input
        FunctionCallNode inputCall = new FunctionCallNode("Input",
            Collections.emptyList(), 1, 1, 1, 7);

        visitor.visit(inputCall);

        // Verify no issues for Input[] itself
        verify(sensor, never()).queueIssue(any(), any(Integer.class), any(), any());
    }

    @Test
    void testSQLFunctionsAllVariants() {
        // Test SQLSelect
        IdentifierNode conn = new IdentifierNode("conn", 1, 1, 1, 5);
        IdentifierNode query = new IdentifierNode("query", 1, 7, 1, 12);
        FunctionCallNode sqlSelect = new FunctionCallNode("SQLSelect",
            Arrays.asList(conn, query), 1, 1, 1, 20);

        visitor.visit(sqlSelect);

        // Query with variable should not trigger (no concatenation)
        verify(sensor, never()).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.SQL_INJECTION_KEY), any(String.class));
    }

    @Test
    void testAllDangerousFileOps() {
        String[] dangerousOps = {"DeleteFile", "DeleteDirectory", "RenameFile",
            "SystemOpen", "CreateDirectory", "CopyFile", "CopyDirectory"};

        for (String op : dangerousOps) {
            IdentifierNode path = new IdentifierNode("path", 1, 1, 1, 5);
            FunctionCallNode fileOp = new FunctionCallNode(op,
                Collections.singletonList(path), 1, 1, 1, 15);

            visitor.visit(fileOp);
        }

        // All should trigger MISSING_SANITIZATION_KEY
        verify(sensor, atLeastOnce()).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.MISSING_SANITIZATION_KEY), any(String.class));
    }

    @Test
    void testCommandInjectionWithNullArgs() {
        // Run without arguments
        FunctionCallNode runCall = new FunctionCallNode("Run", null, 1, 1, 1, 5);
        visitor.visit(runCall);
        verify(sensor, never()).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.COMMAND_INJECTION_KEY), any(String.class));
    }

    @Test
    void testCommandInjectionWithEmptyArgs() {
        // Run with empty arguments list
        FunctionCallNode runCall = new FunctionCallNode("Run", Collections.emptyList(), 1, 1, 1, 5);
        visitor.visit(runCall);
        verify(sensor, never()).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.COMMAND_INJECTION_KEY), any(String.class));
    }

    @Test
    void testSqlInjectionWithSQLInsert() {
        // SQLInsert[conn, query] with concatenation
        IdentifierNode conn = new IdentifierNode("conn", 1, 1, 1, 5);
        LiteralNode query1 = new LiteralNode("INSERT INTO users VALUES ('", LiteralNode.LiteralType.STRING, 1, 1, 1, 10);
        IdentifierNode userName = new IdentifierNode("userName", 1, 15, 1, 23);
        OperatorNode concat = new OperatorNode(OperatorNode.OperatorType.ADD,
            query1, userName, "<>", 1, 1, 1, 23);
        FunctionCallNode sqlInsert = new FunctionCallNode("SQLInsert",
            Arrays.asList(conn, concat), 1, 1, 1, 35);

        visitor.visit(sqlInsert);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.SQL_INJECTION_KEY), any(String.class));
    }

    @Test
    void testSqlInjectionWithSQLUpdate() {
        // SQLUpdate[conn, query] with concatenation
        IdentifierNode conn = new IdentifierNode("conn", 1, 1, 1, 5);
        LiteralNode query1 = new LiteralNode("UPDATE users SET name='", LiteralNode.LiteralType.STRING, 1, 1, 1, 10);
        IdentifierNode userName = new IdentifierNode("userName", 1, 15, 1, 23);
        OperatorNode concat = new OperatorNode(OperatorNode.OperatorType.ADD,
            query1, userName, "<>", 1, 1, 1, 23);
        FunctionCallNode sqlUpdate = new FunctionCallNode("SQLUpdate",
            Arrays.asList(conn, concat), 1, 1, 1, 35);

        visitor.visit(sqlUpdate);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.SQL_INJECTION_KEY), any(String.class));
    }

    @Test
    void testSqlInjectionWithSQLDelete() {
        // SQLDelete[conn, query] with concatenation
        IdentifierNode conn = new IdentifierNode("conn", 1, 1, 1, 5);
        LiteralNode query1 = new LiteralNode("DELETE FROM users WHERE id=", LiteralNode.LiteralType.STRING, 1, 1, 1, 10);
        IdentifierNode userId = new IdentifierNode("userId", 1, 15, 1, 21);
        OperatorNode concat = new OperatorNode(OperatorNode.OperatorType.ADD,
            query1, userId, "<>", 1, 1, 1, 21);
        FunctionCallNode sqlDelete = new FunctionCallNode("SQLDelete",
            Arrays.asList(conn, concat), 1, 1, 1, 32);

        visitor.visit(sqlDelete);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.SQL_INJECTION_KEY), any(String.class));
    }

    @Test
    void testSqlInjectionWithLessThanTwoArgs() {
        // SQLExecute with only one arg
        IdentifierNode conn = new IdentifierNode("conn", 1, 1, 1, 5);
        FunctionCallNode sqlExecute = new FunctionCallNode("SQLExecute",
            Collections.singletonList(conn), 1, 1, 1, 15);

        visitor.visit(sqlExecute);

        verify(sensor, never()).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.SQL_INJECTION_KEY), any(String.class));
    }

    @Test
    void testCodeInjectionWithEvaluate() {
        // Evaluate[userInput] - vulnerable
        IdentifierNode userInput = new IdentifierNode("userInput", 1, 1, 1, 10);
        FunctionCallNode evaluate = new FunctionCallNode("Evaluate",
            Collections.singletonList(userInput), 1, 1, 1, 20);

        visitor.visit(evaluate);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.CODE_INJECTION_KEY), any(String.class));
    }

    @Test
    void testPathTraversalWithExport() {
        // Export[data, filePath] where filePath has variable
        IdentifierNode data = new IdentifierNode("data", 1, 1, 1, 5);
        IdentifierNode filePath = new IdentifierNode("filePath", 1, 7, 1, 15);
        FunctionCallNode exportCall = new FunctionCallNode("Export",
            Arrays.asList(filePath, data), 1, 1, 1, 23);

        visitor.visit(exportCall);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.PATH_TRAVERSAL_KEY), any(String.class));
    }

    @Test
    void testPathTraversalWithGet() {
        // Get[filePath] where filePath is variable
        IdentifierNode filePath = new IdentifierNode("filePath", 1, 1, 1, 9);
        FunctionCallNode getCall = new FunctionCallNode("Get",
            Collections.singletonList(filePath), 1, 1, 1, 15);

        visitor.visit(getCall);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.PATH_TRAVERSAL_KEY), any(String.class));
    }

    @Test
    void testPathTraversalWithPut() {
        // Put[expr, filePath] where filePath is variable
        IdentifierNode expr = new IdentifierNode("expr", 1, 1, 1, 5);
        IdentifierNode filePath = new IdentifierNode("filePath", 1, 7, 1, 15);
        FunctionCallNode putCall = new FunctionCallNode("Put",
            Arrays.asList(filePath, expr), 1, 1, 1, 20);

        visitor.visit(putCall);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.PATH_TRAVERSAL_KEY), any(String.class));
    }

    @Test
    void testPathTraversalWithOpenRead() {
        // OpenRead[filePath] where filePath is variable
        IdentifierNode filePath = new IdentifierNode("filePath", 1, 1, 1, 9);
        FunctionCallNode openRead = new FunctionCallNode("OpenRead",
            Collections.singletonList(filePath), 1, 1, 1, 18);

        visitor.visit(openRead);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.PATH_TRAVERSAL_KEY), any(String.class));
    }

    @Test
    void testPathTraversalWithOpenWrite() {
        // OpenWrite[filePath] where filePath is variable
        IdentifierNode filePath = new IdentifierNode("filePath", 1, 1, 1, 9);
        FunctionCallNode openWrite = new FunctionCallNode("OpenWrite",
            Collections.singletonList(filePath), 1, 1, 1, 19);

        visitor.visit(openWrite);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.PATH_TRAVERSAL_KEY), any(String.class));
    }

    @Test
    void testPathTraversalWithOpenAppend() {
        // OpenAppend[filePath] where filePath is variable
        IdentifierNode filePath = new IdentifierNode("filePath", 1, 1, 1, 9);
        FunctionCallNode openAppend = new FunctionCallNode("OpenAppend",
            Collections.singletonList(filePath), 1, 1, 1, 20);

        visitor.visit(openAppend);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.PATH_TRAVERSAL_KEY), any(String.class));
    }

    @Test
    void testWeakCryptographySHA1DashVariant() {
        // Hash[data, "SHA-1"] with dash variant
        IdentifierNode data = new IdentifierNode("data", 1, 1, 1, 5);
        LiteralNode sha1 = new LiteralNode("SHA-1", LiteralNode.LiteralType.STRING, 1, 7, 1, 14);
        FunctionCallNode hashCall = new FunctionCallNode("Hash",
            Arrays.asList(data, sha1), 1, 1, 1, 20);

        visitor.visit(hashCall);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.WEAK_CRYPTOGRAPHY_KEY), any(String.class));
    }

    @Test
    void testWeakCryptographyHashSafe() {
        // Hash[data, "SHA256"] - safe algorithm
        IdentifierNode data = new IdentifierNode("data", 1, 1, 1, 5);
        LiteralNode sha256 = new LiteralNode("SHA256", LiteralNode.LiteralType.STRING, 1, 7, 1, 15);
        FunctionCallNode hashCall = new FunctionCallNode("Hash",
            Arrays.asList(data, sha256), 1, 1, 1, 21);

        visitor.visit(hashCall);

        verify(sensor, never()).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.WEAK_CRYPTOGRAPHY_KEY), any(String.class));
    }

    @Test
    void testSSRFWithURLRead() {
        // URLRead[url] where url is variable
        IdentifierNode url = new IdentifierNode("url", 1, 1, 1, 4);
        FunctionCallNode urlRead = new FunctionCallNode("URLRead",
            Collections.singletonList(url), 1, 1, 1, 12);

        visitor.visit(urlRead);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.SSRF_KEY), any(String.class));
    }

    @Test
    void testSSRFWithURLExecute() {
        // URLExecute[url] where url is variable
        IdentifierNode url = new IdentifierNode("url", 1, 1, 1, 4);
        FunctionCallNode urlExecute = new FunctionCallNode("URLExecute",
            Collections.singletonList(url), 1, 1, 1, 15);

        visitor.visit(urlExecute);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.SSRF_KEY), any(String.class));
    }

    @Test
    void testSSRFWithServiceExecute() {
        // ServiceExecute[service, url] where url is variable
        IdentifierNode service = new IdentifierNode("service", 1, 1, 1, 8);
        IdentifierNode url = new IdentifierNode("url", 1, 10, 1, 13);
        FunctionCallNode serviceExecute = new FunctionCallNode("ServiceExecute",
            Arrays.asList(url, service), 1, 1, 1, 28);

        visitor.visit(serviceExecute);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.SSRF_KEY), any(String.class));
    }

    @Test
    void testInsecureDeserializationGetWithHttpsUrl() {
        // Get["https://example.com/code.m"] - loading code from HTTPS URL
        LiteralNode urlPath = new LiteralNode("https://example.com/code.m",
            LiteralNode.LiteralType.STRING, 1, 1, 1, 28);
        FunctionCallNode getCall = new FunctionCallNode("Get",
            Collections.singletonList(urlPath), 1, 1, 1, 36);

        visitor.visit(getCall);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.INSECURE_DESERIALIZATION_KEY), any(String.class));
    }

    @Test
    void testInsecureDeserializationImportSafeFormat() {
        // Import[file, "JSON"] - safe format
        IdentifierNode file = new IdentifierNode("file", 1, 1, 1, 5);
        LiteralNode json = new LiteralNode("JSON", LiteralNode.LiteralType.STRING, 1, 7, 1, 13);
        FunctionCallNode importCall = new FunctionCallNode("Import",
            Arrays.asList(file, json), 1, 1, 1, 20);

        visitor.visit(importCall);

        verify(sensor, never()).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.INSECURE_DESERIALIZATION_KEY), any(String.class));
    }

    @Test
    void testUnsafeSymbolWithToExpression() {
        // ToExpression triggers UNSAFE_SYMBOL_KEY
        IdentifierNode varName = new IdentifierNode("varName", 1, 1, 1, 8);
        FunctionCallNode toExpr = new FunctionCallNode("ToExpression",
            Collections.singletonList(varName), 1, 1, 1, 21);

        visitor.visit(toExpr);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.UNSAFE_SYMBOL_KEY), any(String.class));
    }

    @Test
    void testInsecureRandomWithRandomChoice() {
        // RandomChoice[] - insecure for cryptographic use
        FunctionCallNode randomChoice = new FunctionCallNode("RandomChoice",
            Collections.emptyList(), 1, 1, 1, 14);

        visitor.visit(randomChoice);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.INSECURE_RANDOM_EXPANDED_KEY), any(String.class));
    }

    @Test
    void testDynamicInjectionWithSymbol() {
        // Dynamic[Symbol[input]] - vulnerable
        IdentifierNode input = new IdentifierNode("input", 1, 1, 1, 6);
        FunctionCallNode symbol = new FunctionCallNode("Symbol",
            Collections.singletonList(input), 1, 1, 1, 13);
        FunctionCallNode dynamic = new FunctionCallNode("Dynamic",
            Collections.singletonList(symbol), 1, 1, 1, 21);

        visitor.visit(dynamic);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.DYNAMIC_INJECTION_KEY), any(String.class));
    }

    @Test
    void testToExpressionOnInputWithInputKeyword() {
        // ToExpression[inputData] where variable name contains "input"
        IdentifierNode inputData = new IdentifierNode("inputData", 1, 1, 1, 10);
        FunctionCallNode toExpr = new FunctionCallNode("ToExpression",
            Collections.singletonList(inputData), 1, 1, 1, 24);

        visitor.visit(toExpr);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.TOEXPRESSION_ON_INPUT_KEY), any(String.class));
    }

    @Test
    void testToExpressionOnInputWithRequestKeyword() {
        // ToExpression[requestParam] where variable name contains "request"
        IdentifierNode requestParam = new IdentifierNode("requestParam", 1, 1, 1, 13);
        FunctionCallNode toExpr = new FunctionCallNode("ToExpression",
            Collections.singletonList(requestParam), 1, 1, 1, 27);

        visitor.visit(toExpr);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.TOEXPRESSION_ON_INPUT_KEY), any(String.class));
    }

    @Test
    void testUnsanitizedRunProcessWithRun() {
        // Run[userInput] - critical vulnerability
        IdentifierNode userInput = new IdentifierNode("userInput", 1, 1, 1, 10);
        FunctionCallNode run = new FunctionCallNode("Run",
            Collections.singletonList(userInput), 1, 1, 1, 15);

        visitor.visit(run);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.UNSANITIZED_RUNPROCESS_KEY), any(String.class));
    }

    @Test
    void testMissingCloudAuthWithFormFunction() {
        // CloudDeploy[FormFunction[...]] without Permissions
        IdentifierNode fields = new IdentifierNode("fields", 1, 1, 1, 7);
        IdentifierNode handler = new IdentifierNode("handler", 1, 9, 1, 16);
        FunctionCallNode formFunc = new FunctionCallNode("FormFunction",
            Arrays.asList(fields, handler), 1, 1, 1, 29);
        FunctionCallNode cloudDeploy = new FunctionCallNode("CloudDeploy",
            Collections.singletonList(formFunc), 1, 1, 1, 42);

        visitor.visit(cloudDeploy);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.MISSING_CLOUD_AUTH_KEY), any(String.class));
    }

    @Test
    void testMissingCloudAuthWithPermissions() {
        // CloudDeploy[APIFunction[...], Permissions -> "Private"] - has Permissions
        IdentifierNode handler = new IdentifierNode("handler", 1, 1, 1, 8);
        FunctionCallNode apiFunc = new FunctionCallNode("APIFunction",
            Collections.singletonList(handler), 1, 1, 1, 20);
        IdentifierNode permissions = new IdentifierNode("Permissions", 1, 22, 1, 33);
        FunctionCallNode cloudDeploy = new FunctionCallNode("CloudDeploy",
            Arrays.asList(apiFunc, permissions), 1, 1, 1, 45);

        visitor.visit(cloudDeploy);

        verify(sensor, never()).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.MISSING_CLOUD_AUTH_KEY), any(String.class));
    }

    @Test
    void testNeedsGetUntrustedWithGet() {
        // Get[userPackage] - loading package from user input
        IdentifierNode userPackage = new IdentifierNode("userPackage", 1, 1, 1, 12);
        FunctionCallNode getCall = new FunctionCallNode("Get",
            Collections.singletonList(userPackage), 1, 1, 1, 17);

        visitor.visit(getCall);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.NEEDS_GET_UNTRUSTED_KEY), any(String.class));
    }

    @Test
    void testExposingSensitiveDataWithSystemCredential() {
        // CloudDeploy[Function[[], SystemCredential["key"]]]
        IdentifierNode systemCred = new IdentifierNode("SystemCredential", 1, 1, 1, 17);
        FunctionCallNode cloudDeploy = new FunctionCallNode("CloudDeploy",
            Collections.singletonList(systemCred), 1, 1, 1, 30);

        visitor.visit(cloudDeploy);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.EXPOSING_SENSITIVE_DATA_KEY), any(String.class));
    }

    @Test
    void testMissingFormFunctionValidationWithRestricted() {
        // FormFunction with Restricted - has validation
        IdentifierNode restricted = new IdentifierNode("Restricted", 1, 1, 1, 11);
        IdentifierNode handler = new IdentifierNode("handler", 1, 13, 1, 20);
        FunctionCallNode formFunc = new FunctionCallNode("FormFunction",
            Arrays.asList(restricted, handler), 1, 1, 1, 33);

        visitor.visit(formFunc);

        verify(sensor, never()).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.MISSING_FORMFUNCTION_VALIDATION_KEY), any(String.class));
    }

    @Test
    void testMissingFormFunctionValidationWithInterpreter() {
        // FormFunction with Interpreter - has validation
        IdentifierNode interpreter = new IdentifierNode("Interpreter", 1, 1, 1, 12);
        IdentifierNode handler = new IdentifierNode("handler", 1, 14, 1, 21);
        FunctionCallNode formFunc = new FunctionCallNode("FormFunction",
            Arrays.asList(interpreter, handler), 1, 1, 1, 34);

        visitor.visit(formFunc);

        verify(sensor, never()).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.MISSING_FORMFUNCTION_VALIDATION_KEY), any(String.class));
    }

    @Test
    void testHardcodedCredentialsShortString() {
        // password = "short" - too short, should not trigger
        LiteralNode password = new LiteralNode("short", LiteralNode.LiteralType.STRING, 1, 1, 1, 7);

        visitor.visit(password);

        verify(sensor, never()).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.HARDCODED_CREDENTIALS_KEY), any(String.class));
    }

    @Test
    void testHardcodedCredentialsPlaceholderVariants() {
        String[] placeholders = {"example_password", "password_placeholder",
            "xxx_secret", "your_api_key", "password", "secret", "********", "xxxxxxxx"};

        for (String placeholder : placeholders) {
            LiteralNode literal = new LiteralNode(placeholder, LiteralNode.LiteralType.STRING, 1, 1, 1, 15);
            visitor = new VulnerabilityVisitor(inputFile, sensor);
            visitor.visit(literal);
        }

        // Should not trigger for any placeholders
        verify(sensor, never()).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.HARDCODED_CREDENTIALS_KEY), any(String.class));
    }

    @Test
    void testHardcodedApiKeyShortString() {
        // apiKey = "short" - too short, should not trigger
        LiteralNode apiKey = new LiteralNode("short", LiteralNode.LiteralType.STRING, 1, 1, 1, 7);

        visitor.visit(apiKey);

        verify(sensor, never()).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.HARDCODED_API_KEYS_KEY), any(String.class));
    }

    @Test
    void testHardcodedApiKeyWithSpecialChars() {
        // apiKey with special characters should not match pattern
        LiteralNode apiKey = new LiteralNode("this is not an api key!@#$",
            LiteralNode.LiteralType.STRING, 1, 1, 1, 28);

        visitor.visit(apiKey);

        verify(sensor, never()).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.HARDCODED_API_KEYS_KEY), any(String.class));
    }

    @Test
    void testLiteralNodeNonString() {
        // Literal that's not a string (integer) should not trigger any issues
        LiteralNode number = new LiteralNode(12345, LiteralNode.LiteralType.INTEGER, 1, 1, 1, 6);

        visitor.visit(number);

        verify(sensor, never()).queueIssue(any(), any(Integer.class), any(), any());
    }

    @Test
    void testTrackUserInputWithInputString() {
        // InputString[] marks context as user input
        FunctionCallNode inputString = new FunctionCallNode("InputString",
            Collections.emptyList(), 1, 1, 1, 12);

        visitor.visit(inputString);

        verify(sensor, never()).queueIssue(any(), any(Integer.class), any(), any());
    }

    @Test
    void testTrackUserInputWithURLFetch() {
        // URLFetch[url] marks context as user input
        LiteralNode url = new LiteralNode("http://example.com", LiteralNode.LiteralType.STRING, 1, 1, 1, 20);
        FunctionCallNode urlFetch = new FunctionCallNode("URLFetch",
            Collections.singletonList(url), 1, 1, 1, 30);

        visitor.visit(urlFetch);

        // Should trigger SSRF check, not track user input when literal
        verify(sensor, never()).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.SSRF_KEY), any(String.class));
    }

    @Test
    void testTrackUserInputWithAPIFunction() {
        // APIFunction[...] marks context as user input
        IdentifierNode handler = new IdentifierNode("handler", 1, 1, 1, 8);
        FunctionCallNode apiFunc = new FunctionCallNode("APIFunction",
            Collections.singletonList(handler), 1, 1, 1, 20);

        visitor.visit(apiFunc);

        verify(sensor, never()).queueIssue(any(), any(Integer.class), any(), any());
    }

    @Test
    void testTrackUserInputWithCloudGet() {
        // CloudGet[url] marks context as user input
        IdentifierNode url = new IdentifierNode("url", 1, 1, 1, 4);
        FunctionCallNode cloudGet = new FunctionCallNode("CloudGet",
            Collections.singletonList(url), 1, 1, 1, 13);

        visitor.visit(cloudGet);

        verify(sensor, never()).queueIssue(any(), any(Integer.class), any(), any());
    }

    @Test
    void testNestedConcatenationDetection() {
        // Nested concatenation: "SELECT " <> ("FROM " <> table)
        LiteralNode select = new LiteralNode("SELECT ", LiteralNode.LiteralType.STRING, 1, 1, 1, 9);
        LiteralNode from = new LiteralNode("FROM ", LiteralNode.LiteralType.STRING, 1, 11, 1, 17);
        IdentifierNode table = new IdentifierNode("table", 1, 19, 1, 24);
        OperatorNode innerConcat = new OperatorNode(OperatorNode.OperatorType.ADD,
            from, table, "<>", 1, 11, 1, 24);
        OperatorNode outerConcat = new OperatorNode(OperatorNode.OperatorType.ADD,
            select, innerConcat, "<>", 1, 1, 1, 24);

        IdentifierNode conn = new IdentifierNode("conn", 1, 1, 1, 5);
        FunctionCallNode sqlExecute = new FunctionCallNode("SQLExecute",
            Arrays.asList(conn, outerConcat), 1, 1, 1, 35);

        visitor.visit(sqlExecute);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.SQL_INJECTION_KEY), any(String.class));
    }

    @Test
    void testStringJoinOperator() {
        // Test ~~ operator (StringJoin)
        LiteralNode str1 = new LiteralNode("hello", LiteralNode.LiteralType.STRING, 1, 1, 1, 7);
        IdentifierNode str2 = new IdentifierNode("name", 1, 9, 1, 13);
        OperatorNode stringJoin = new OperatorNode(OperatorNode.OperatorType.ADD,
            str1, str2, "~~", 1, 1, 1, 13);

        FunctionCallNode run = new FunctionCallNode("Run",
            Collections.singletonList(stringJoin), 1, 1, 1, 18);

        visitor.visit(run);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.COMMAND_INJECTION_KEY), any(String.class));
    }

    @Test
    void testNestedVariableDetection() {
        // Nested variable in function call argument
        IdentifierNode innerVar = new IdentifierNode("innerVar", 1, 1, 1, 9);
        FunctionCallNode innerFunc = new FunctionCallNode("ToString",
            Collections.singletonList(innerVar), 1, 1, 1, 18);
        FunctionCallNode runProcess = new FunctionCallNode("RunProcess",
            Collections.singletonList(innerFunc), 1, 1, 1, 30);

        visitor.visit(runProcess);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.COMMAND_INJECTION_KEY), any(String.class));
    }

    @Test
    void testSystemVariablesAllVariants() {
        String[] sysVars = {"$UserName", "$MachineName", "$HomeDirectory",
            "$InstallationDirectory", "$ProcessID"};

        for (String sysVar : sysVars) {
            IdentifierNode systemVar = new IdentifierNode(sysVar, 1, 1, 1, 15);
            FunctionCallNode cloudDeploy = new FunctionCallNode("CloudDeploy",
                Collections.singletonList(systemVar), 1, 1, 1, 28);

            visitor = new VulnerabilityVisitor(inputFile, sensor);
            visitor.visit(cloudDeploy);
        }

        verify(sensor, atLeastOnce()).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.EXPOSING_SENSITIVE_DATA_KEY), any(String.class));
    }

    @Test
    void testReportProfileStatsLowActivity() {
        // Low activity should not trigger profiling output
        IdentifierNode variable = new IdentifierNode("var", 1, 1, 1, 4);
        FunctionCallNode call = new FunctionCallNode("Print",
            Collections.singletonList(variable), 1, 1, 1, 10);
        visitor.visit(call);

        // Should complete without error even with low activity
        visitor.reportProfileStats();
    }

    @Test
    void testVisitorWithNullSensor() {
        // Test visitor with null sensor (should not crash)
        VulnerabilityVisitor nullSensorVisitor = new VulnerabilityVisitor(inputFile, null);

        IdentifierNode cmd = new IdentifierNode("cmd", 1, 1, 1, 4);
        FunctionCallNode run = new FunctionCallNode("Run",
            Collections.singletonList(cmd), 1, 1, 1, 9);

        // Should not crash even with null sensor
        nullSensorVisitor.visit(run);
        nullSensorVisitor.reportProfileStats();
    }

    @Test
    void testHashWithNonLiteralAlgorithm() {
        // Hash[data, algo] where algo is not a literal
        IdentifierNode data = new IdentifierNode("data", 1, 1, 1, 5);
        IdentifierNode algo = new IdentifierNode("hashAlgo", 1, 7, 1, 15);
        FunctionCallNode hashCall = new FunctionCallNode("Hash",
            Arrays.asList(data, algo), 1, 1, 1, 21);

        visitor.visit(hashCall);

        // Should not trigger if algorithm is not a literal (can't determine if weak)
        verify(sensor, never()).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.WEAK_CRYPTOGRAPHY_KEY), any(String.class));
    }

    @Test
    void testHashWithOneArgument() {
        // Hash[data] - only one argument
        IdentifierNode data = new IdentifierNode("data", 1, 1, 1, 5);
        FunctionCallNode hashCall = new FunctionCallNode("Hash",
            Collections.singletonList(data), 1, 1, 1, 11);

        visitor.visit(hashCall);

        verify(sensor, never()).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.WEAK_CRYPTOGRAPHY_KEY), any(String.class));
    }

    @Test
    void testImportXMLNonLiteralFormat() {
        // Import[file, format] where format is not a literal
        IdentifierNode file = new IdentifierNode("file", 1, 1, 1, 5);
        IdentifierNode format = new IdentifierNode("format", 1, 7, 1, 13);
        FunctionCallNode importCall = new FunctionCallNode("Import",
            Arrays.asList(file, format), 1, 1, 1, 20);

        visitor.visit(importCall);

        // Should not trigger XXE if format is not a literal (can't determine if XML)
        verify(sensor, never()).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.XXE_KEY), any(String.class));
    }

    @Test
    void testCloudDeployWithNonFunctionCallArg() {
        // CloudDeploy with non-function call argument (should still check permissions)
        IdentifierNode expr = new IdentifierNode("expr", 1, 1, 1, 5);
        FunctionCallNode cloudDeploy = new FunctionCallNode("CloudDeploy",
            Collections.singletonList(expr), 1, 1, 1, 17);

        visitor.visit(cloudDeploy);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.UNSAFE_CLOUD_DEPLOY_KEY), any(String.class));
    }

    @Test
    void testDynamicWithoutToExpressionOrSymbol() {
        // Dynamic[x] without ToExpression or Symbol - safe
        IdentifierNode x = new IdentifierNode("x", 1, 1, 1, 2);
        FunctionCallNode dynamic = new FunctionCallNode("Dynamic",
            Collections.singletonList(x), 1, 1, 1, 10);

        visitor.visit(dynamic);

        verify(sensor, never()).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.DYNAMIC_INJECTION_KEY), any(String.class));
    }

    @Test
    void testToExpressionWithNonIdentifierArg() {
        // ToExpression with literal string (safe for TOEXPRESSION_ON_INPUT check)
        LiteralNode expr = new LiteralNode("x + 1", LiteralNode.LiteralType.STRING, 1, 1, 1, 7);
        FunctionCallNode toExpr = new FunctionCallNode("ToExpression",
            Collections.singletonList(expr), 1, 1, 1, 20);

        visitor.visit(toExpr);

        // Should trigger CODE_INJECTION or UNSAFE_SYMBOL but not TOEXPRESSION_ON_INPUT
        verify(sensor, never()).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.TOEXPRESSION_ON_INPUT_KEY), any(String.class));
    }

    @Test
    void testRunProcessWithNonUserInputVariable() {
        // RunProcess[safeCmd] where safeCmd is not a user input variable
        IdentifierNode safeCmd = new IdentifierNode("safeCommand", 1, 1, 1, 12);
        FunctionCallNode runProcess = new FunctionCallNode("RunProcess",
            Collections.singletonList(safeCmd), 1, 1, 1, 24);

        visitor.visit(runProcess);

        // Should trigger COMMAND_INJECTION but not UNSANITIZED_RUNPROCESS
        verify(sensor, never()).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.UNSANITIZED_RUNPROCESS_KEY), any(String.class));
    }

    @Test
    void testNeedsWithNonUserInputVariable() {
        // Needs[package] where package is not a user input variable
        IdentifierNode packageVar = new IdentifierNode("myPackage", 1, 1, 1, 10);
        FunctionCallNode needs = new FunctionCallNode("Needs",
            Collections.singletonList(packageVar), 1, 1, 1, 17);

        visitor.visit(needs);

        // Should not trigger if not user input variable
        verify(sensor, never()).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.NEEDS_GET_UNTRUSTED_KEY), any(String.class));
    }

    @Test
    void testCloudDeployWithoutSystemVariables() {
        // CloudDeploy without system variables
        IdentifierNode expr = new IdentifierNode("normalVar", 1, 1, 1, 10);
        FunctionCallNode cloudDeploy = new FunctionCallNode("CloudDeploy",
            Collections.singletonList(expr), 1, 1, 1, 23);

        visitor.visit(cloudDeploy);

        // Should trigger UNSAFE_CLOUD_DEPLOY but not EXPOSING_SENSITIVE_DATA
        verify(sensor, never()).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.EXPOSING_SENSITIVE_DATA_KEY), any(String.class));
    }
}
