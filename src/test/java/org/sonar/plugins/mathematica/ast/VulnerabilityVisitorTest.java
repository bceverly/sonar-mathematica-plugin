package org.sonar.plugins.mathematica.ast;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.sonar.api.batch.fs.InputFile;
import org.sonar.plugins.mathematica.rules.MathematicaRulesDefinition;
import org.sonar.plugins.mathematica.rules.MathematicaRulesSensor;

import java.util.Arrays;
import java.util.Collections;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.atLeastOnce;

class VulnerabilityVisitorTest {

    private VulnerabilityVisitor visitor;
    private InputFile inputFile;
    private MathematicaRulesSensor sensor;

    @BeforeEach
    void setUp() {
        inputFile = mock(InputFile.class);
        sensor = mock(MathematicaRulesSensor.class);
        visitor = new VulnerabilityVisitor(inputFile, sensor);
    }

    @Test
    void testCommandInjectionWithRun() {
        // Run[cmd] where cmd is a variable - vulnerable
        IdentifierNode cmdVar = new IdentifierNode("cmd", 1, 1, 1, 4);
        FunctionCallNode runCall = new FunctionCallNode("Run", Collections.singletonList(cmdVar), 1, 1, 1, 10);

        visitor.visit(runCall);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.COMMAND_INJECTION_KEY), any(String.class));
    }

    @Test
    void testCommandInjectionWithRunProcess() {
        // RunProcess["ls " <> input] - vulnerable due to concatenation
        LiteralNode lsCmd = new LiteralNode("ls ", LiteralNode.LiteralType.STRING, 1, 1, 1, 5);
        IdentifierNode input = new IdentifierNode("input", 1, 10, 1, 15);
        OperatorNode concat = new OperatorNode(OperatorNode.OperatorType.ADD,
            lsCmd, input, "<>", 1, 1, 1, 15);
        FunctionCallNode runProcess = new FunctionCallNode("RunProcess",
            Collections.singletonList(concat), 1, 1, 1, 25);

        visitor.visit(runProcess);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.COMMAND_INJECTION_KEY), any(String.class));
    }

    @Test
    void testCommandInjectionSafe() {
        // Run["ls"] - safe, literal command
        LiteralNode lsCmd = new LiteralNode("ls", LiteralNode.LiteralType.STRING, 1, 1, 1, 4);
        FunctionCallNode runCall = new FunctionCallNode("Run", Collections.singletonList(lsCmd), 1, 1, 1, 10);

        visitor.visit(runCall);

        verify(sensor, never()).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.COMMAND_INJECTION_KEY), any(String.class));
    }

    @Test
    void testSqlInjectionWithConcatenation() {
        // SQLExecute[conn, "SELECT * FROM users WHERE name = '" <> userName <> "'"]
        LiteralNode query1 = new LiteralNode("SELECT * FROM users WHERE name = '",
            LiteralNode.LiteralType.STRING, 1, 1, 1, 10);
        IdentifierNode userName = new IdentifierNode("userName", 1, 15, 1, 23);
        LiteralNode query2 = new LiteralNode("'", LiteralNode.LiteralType.STRING, 1, 28, 1, 29);
        OperatorNode concat1 = new OperatorNode(OperatorNode.OperatorType.ADD,
            query1, userName, "<>", 1, 1, 1, 23);
        OperatorNode concat2 = new OperatorNode(OperatorNode.OperatorType.ADD,
            concat1, query2, "<>", 1, 1, 1, 29);

        FunctionCallNode sqlExecute = new FunctionCallNode("SQLExecute",
            Arrays.asList(new IdentifierNode("conn", 1, 1, 1, 5), concat2), 1, 1, 1, 40);

        visitor.visit(sqlExecute);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.SQL_INJECTION_KEY), any(String.class));
    }

    @Test
    void testCodeInjectionWithToExpression() {
        // ToExpression[userInput] - vulnerable
        IdentifierNode userInput = new IdentifierNode("userInput", 1, 1, 1, 10);
        FunctionCallNode toExpr = new FunctionCallNode("ToExpression",
            Collections.singletonList(userInput), 1, 1, 1, 25);

        visitor.visit(toExpr);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.CODE_INJECTION_KEY), any(String.class));
    }

    @Test
    void testCodeInjectionSafe() {
        // ToExpression["x + 1"] - safe, literal expression
        LiteralNode expr = new LiteralNode("x + 1", LiteralNode.LiteralType.STRING, 1, 1, 1, 7);
        FunctionCallNode toExpr = new FunctionCallNode("ToExpression",
            Collections.singletonList(expr), 1, 1, 1, 25);

        visitor.visit(toExpr);

        verify(sensor, never()).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.CODE_INJECTION_KEY), any(String.class));
    }

    @Test
    void testPathTraversalWithImport() {
        // Import[basePath <> userFile] - vulnerable
        IdentifierNode basePath = new IdentifierNode("basePath", 1, 1, 1, 9);
        IdentifierNode userFile = new IdentifierNode("userFile", 1, 15, 1, 23);
        OperatorNode concat = new OperatorNode(OperatorNode.OperatorType.ADD,
            basePath, userFile, "<>", 1, 1, 1, 23);
        FunctionCallNode importCall = new FunctionCallNode("Import",
            Collections.singletonList(concat), 1, 1, 1, 30);

        visitor.visit(importCall);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.PATH_TRAVERSAL_KEY), any(String.class));
    }

    @Test
    void testWeakCryptographyMD5() {
        // Hash[data, "MD5"] - weak algorithm
        IdentifierNode data = new IdentifierNode("data", 1, 1, 1, 5);
        LiteralNode md5 = new LiteralNode("MD5", LiteralNode.LiteralType.STRING, 1, 7, 1, 12);
        FunctionCallNode hashCall = new FunctionCallNode("Hash",
            Arrays.asList(data, md5), 1, 1, 1, 18);

        visitor.visit(hashCall);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.WEAK_CRYPTOGRAPHY_KEY), any(String.class));
    }

    @Test
    void testWeakCryptographySHA1() {
        // Hash[data, "SHA1"] - weak algorithm
        IdentifierNode data = new IdentifierNode("data", 1, 1, 1, 5);
        LiteralNode sha1 = new LiteralNode("SHA1", LiteralNode.LiteralType.STRING, 1, 7, 1, 13);
        FunctionCallNode hashCall = new FunctionCallNode("Hash",
            Arrays.asList(data, sha1), 1, 1, 1, 19);

        visitor.visit(hashCall);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.WEAK_CRYPTOGRAPHY_KEY), any(String.class));
    }

    @Test
    void testWeakCryptographyRandom() {
        // Random[] - insecure for cryptographic use
        FunctionCallNode randomCall = new FunctionCallNode("Random",
            Collections.emptyList(), 1, 1, 1, 8);

        visitor.visit(randomCall);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.WEAK_CRYPTOGRAPHY_KEY), any(String.class));
    }

    @Test
    void testSSRFWithURLFetch() {
        // URLFetch[url] where url is variable - vulnerable
        IdentifierNode url = new IdentifierNode("url", 1, 1, 1, 4);
        FunctionCallNode urlFetch = new FunctionCallNode("URLFetch",
            Collections.singletonList(url), 1, 1, 1, 15);

        visitor.visit(urlFetch);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.SSRF_KEY), any(String.class));
    }

    @Test
    void testInsecureDeserializationMX() {
        // Import[file, "MX"] - insecure format
        IdentifierNode file = new IdentifierNode("file", 1, 1, 1, 5);
        LiteralNode mx = new LiteralNode("MX", LiteralNode.LiteralType.STRING, 1, 7, 1, 11);
        FunctionCallNode importCall = new FunctionCallNode("Import",
            Arrays.asList(file, mx), 1, 1, 1, 18);

        visitor.visit(importCall);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.INSECURE_DESERIALIZATION_KEY), any(String.class));
    }

    @Test
    void testInsecureDeserializationWDX() {
        // Import[file, "WDX"] - insecure format
        IdentifierNode file = new IdentifierNode("file", 1, 1, 1, 5);
        LiteralNode wdx = new LiteralNode("WDX", LiteralNode.LiteralType.STRING, 1, 7, 1, 12);
        FunctionCallNode importCall = new FunctionCallNode("Import",
            Arrays.asList(file, wdx), 1, 1, 1, 19);

        visitor.visit(importCall);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.INSECURE_DESERIALIZATION_KEY), any(String.class));
    }

    @Test
    void testInsecureDeserializationGetWithUrl() {
        // Get["http://example.com/code.m"] - loading code from URL
        LiteralNode urlPath = new LiteralNode("http://example.com/code.m",
            LiteralNode.LiteralType.STRING, 1, 1, 1, 27);
        FunctionCallNode getCall = new FunctionCallNode("Get",
            Collections.singletonList(urlPath), 1, 1, 1, 35);

        visitor.visit(getCall);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.INSECURE_DESERIALIZATION_KEY), any(String.class));
    }

    @Test
    void testUnsafeSymbol() {
        // Symbol[varName] - allows code injection
        IdentifierNode varName = new IdentifierNode("varName", 1, 1, 1, 8);
        FunctionCallNode symbolCall = new FunctionCallNode("Symbol",
            Collections.singletonList(varName), 1, 1, 1, 17);

        visitor.visit(symbolCall);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.UNSAFE_SYMBOL_KEY), any(String.class));
    }

    @Test
    void testXXEVulnerability() {
        // Import[file, "XML"] - vulnerable to XXE
        IdentifierNode file = new IdentifierNode("file", 1, 1, 1, 5);
        LiteralNode xml = new LiteralNode("XML", LiteralNode.LiteralType.STRING, 1, 7, 1, 12);
        FunctionCallNode importCall = new FunctionCallNode("Import",
            Arrays.asList(file, xml), 1, 1, 1, 19);

        visitor.visit(importCall);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.XXE_KEY), any(String.class));
    }

    @Test
    void testMissingSanitization() {
        // DeleteFile[path] - dangerous operation
        IdentifierNode path = new IdentifierNode("path", 1, 1, 1, 5);
        FunctionCallNode deleteFile = new FunctionCallNode("DeleteFile",
            Collections.singletonList(path), 1, 1, 1, 17);

        visitor.visit(deleteFile);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.MISSING_SANITIZATION_KEY), any(String.class));
    }

    @Test
    void testInsecureRandom() {
        // Random[] for security - insecure
        FunctionCallNode randomCall = new FunctionCallNode("Random",
            Collections.emptyList(), 1, 1, 1, 8);

        visitor.visit(randomCall);

        // Should trigger INSECURE_RANDOM_EXPANDED_KEY
        verify(sensor, atLeastOnce()).queueIssue(eq(inputFile), eq(1), any(String.class), any(String.class));
    }

    @Test
    void testUnsafeCloudDeployWithoutPermissions() {
        // CloudDeploy[function] - missing Permissions
        IdentifierNode function = new IdentifierNode("myFunc", 1, 1, 1, 7);
        FunctionCallNode cloudDeploy = new FunctionCallNode("CloudDeploy",
            Collections.singletonList(function), 1, 1, 1, 20);

        visitor.visit(cloudDeploy);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.UNSAFE_CLOUD_DEPLOY_KEY), any(String.class));
    }

    @Test
    void testUnsafeCloudDeployWithPermissions() {
        // CloudDeploy[function, Permissions -> "Private"] - has Permissions
        IdentifierNode function = new IdentifierNode("myFunc", 1, 1, 1, 7);
        IdentifierNode permissions = new IdentifierNode("Permissions", 1, 10, 1, 21);
        FunctionCallNode cloudDeploy = new FunctionCallNode("CloudDeploy",
            Arrays.asList(function, permissions), 1, 1, 1, 30);

        visitor.visit(cloudDeploy);

        verify(sensor, never()).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.UNSAFE_CLOUD_DEPLOY_KEY), any(String.class));
    }

    @Test
    void testDynamicInjectionWithToExpression() {
        // Dynamic[ToExpression[input]] - vulnerable
        IdentifierNode input = new IdentifierNode("input", 1, 1, 1, 6);
        FunctionCallNode toExpr = new FunctionCallNode("ToExpression",
            Collections.singletonList(input), 1, 1, 1, 20);
        FunctionCallNode dynamic = new FunctionCallNode("Dynamic",
            Collections.singletonList(toExpr), 1, 1, 1, 28);

        visitor.visit(dynamic);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.DYNAMIC_INJECTION_KEY), any(String.class));
    }

    @Test
    void testToExpressionOnUserInput() {
        // ToExpression[userInput] where userInput is a user input variable
        IdentifierNode userInput = new IdentifierNode("userInput", 1, 1, 1, 10);
        FunctionCallNode toExpr = new FunctionCallNode("ToExpression",
            Collections.singletonList(userInput), 1, 1, 1, 25);

        visitor.visit(toExpr);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.TOEXPRESSION_ON_INPUT_KEY), any(String.class));
    }

    @Test
    void testUnsanitizedRunProcessWithUserInput() {
        // RunProcess[userInput] - critical vulnerability
        IdentifierNode userInput = new IdentifierNode("userInput", 1, 1, 1, 10);
        FunctionCallNode runProcess = new FunctionCallNode("RunProcess",
            Collections.singletonList(userInput), 1, 1, 1, 22);

        visitor.visit(runProcess);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.UNSANITIZED_RUNPROCESS_KEY), any(String.class));
    }

    @Test
    void testMissingCloudAuth() {
        // CloudDeploy[APIFunction[...]] without Permissions
        IdentifierNode handler = new IdentifierNode("handler", 1, 1, 1, 8);
        FunctionCallNode apiFunc = new FunctionCallNode("APIFunction",
            Collections.singletonList(handler), 1, 1, 1, 20);
        FunctionCallNode cloudDeploy = new FunctionCallNode("CloudDeploy",
            Collections.singletonList(apiFunc), 1, 1, 1, 33);

        visitor.visit(cloudDeploy);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.MISSING_CLOUD_AUTH_KEY), any(String.class));
    }

    @Test
    void testNeedsGetUntrusted() {
        // Needs[userPackage] - loading package from user input
        IdentifierNode userPackage = new IdentifierNode("userPackage", 1, 1, 1, 12);
        FunctionCallNode needs = new FunctionCallNode("Needs",
            Collections.singletonList(userPackage), 1, 1, 1, 19);

        visitor.visit(needs);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.NEEDS_GET_UNTRUSTED_KEY), any(String.class));
    }

    @Test
    void testExposingSensitiveData() {
        // CloudDeploy[Function[[], $UserName]] - exposes system variable
        IdentifierNode userName = new IdentifierNode("$UserName", 1, 1, 1, 10);
        FunctionCallNode cloudDeploy = new FunctionCallNode("CloudDeploy",
            Collections.singletonList(userName), 1, 1, 1, 22);

        visitor.visit(cloudDeploy);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.EXPOSING_SENSITIVE_DATA_KEY), any(String.class));
    }

    @Test
    void testMissingFormFunctionValidation() {
        // FormFunction[{field}, handler] without validation
        IdentifierNode field = new IdentifierNode("field", 1, 1, 1, 6);
        IdentifierNode handler = new IdentifierNode("handler", 1, 8, 1, 15);
        FunctionCallNode formFunc = new FunctionCallNode("FormFunction",
            Arrays.asList(field, handler), 1, 1, 1, 28);

        visitor.visit(formFunc);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.MISSING_FORMFUNCTION_VALIDATION_KEY), any(String.class));
    }

    @Test
    void testHardcodedCredentials() {
        // password = "MySecretPassword123" - hardcoded credential
        LiteralNode password = new LiteralNode("MySecretPassword123",
            LiteralNode.LiteralType.STRING, 1, 1, 1, 21);

        visitor.visit(password);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.HARDCODED_CREDENTIALS_KEY), any(String.class));
    }

    @Test
    void testHardcodedCredentialsPlaceholder() {
        // password = "your_password_here" - placeholder, should not trigger
        LiteralNode password = new LiteralNode("your_password_here",
            LiteralNode.LiteralType.STRING, 1, 1, 1, 20);

        visitor.visit(password);

        verify(sensor, never()).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.HARDCODED_CREDENTIALS_KEY), any(String.class));
    }

    @Test
    void testHardcodedApiKey() {
        // apiKey = "sk_live_51234567890abcdefghijk" - looks like API key
        LiteralNode apiKey = new LiteralNode("sk_live_51234567890abcdefghijk",
            LiteralNode.LiteralType.STRING, 1, 1, 1, 31);

        visitor.visit(apiKey);

        verify(sensor).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.HARDCODED_API_KEYS_KEY), any(String.class));
    }

    @Test
    void testVisitFunctionDef() {
        // Test that FunctionDefNode visits children
        LiteralNode body = new LiteralNode(42, LiteralNode.LiteralType.INTEGER, 1, 10, 1, 12);
        FunctionDefNode funcDef = new FunctionDefNode("testFunc",
            Collections.emptyList(), body, true, 1, 1, 1, 15);

        visitor.visit(funcDef);

        // Should not throw and should visit children
    }

    @Test
    void testVisitIdentifier() {
        // Test that IdentifierNode with system variable is tracked
        IdentifierNode userName = new IdentifierNode("$UserName", 1, 1, 1, 10);

        visitor.visit(userName);

        // Should not throw
    }

    @Test
    void testReportProfileStatsWithHighActivity() {
        // Generate high activity to trigger profiling output
        for (int i = 0; i < 100; i++) {
            IdentifierNode var = new IdentifierNode("var" + i, 1, 1, 1, 5);
            FunctionCallNode call = new FunctionCallNode("Run",
                Collections.singletonList(var), 1, 1, 1, 10);
            visitor.visit(call);
        }

        // Should not throw
        visitor.reportProfileStats();
    }

    @Test
    void testTrackUserInputFunction() {
        // Input[] marks context as user input
        FunctionCallNode inputCall = new FunctionCallNode("Input",
            Collections.emptyList(), 1, 1, 1, 7);

        visitor.visit(inputCall);

        // Should track user input context
    }

    @Test
    void testSQLFunctionsAllVariants() {
        // Test SQLSelect
        IdentifierNode conn = new IdentifierNode("conn", 1, 1, 1, 5);
        IdentifierNode query = new IdentifierNode("query", 1, 7, 1, 12);
        FunctionCallNode sqlSelect = new FunctionCallNode("SQLSelect",
            Arrays.asList(conn, query), 1, 1, 1, 20);

        visitor.visit(sqlSelect);

        // Query with variable should not trigger (no concatenation)
        verify(sensor, never()).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.SQL_INJECTION_KEY), any(String.class));
    }

    @Test
    void testAllDangerousFileOps() {
        String[] dangerousOps = {"DeleteFile", "DeleteDirectory", "RenameFile",
            "SystemOpen", "CreateDirectory", "CopyFile", "CopyDirectory"};

        for (String op : dangerousOps) {
            IdentifierNode path = new IdentifierNode("path", 1, 1, 1, 5);
            FunctionCallNode fileOp = new FunctionCallNode(op,
                Collections.singletonList(path), 1, 1, 1, 15);

            visitor.visit(fileOp);
        }

        // All should trigger MISSING_SANITIZATION_KEY
        verify(sensor, atLeastOnce()).queueIssue(eq(inputFile), eq(1),
            eq(MathematicaRulesDefinition.MISSING_SANITIZATION_KEY), any(String.class));
    }
}
