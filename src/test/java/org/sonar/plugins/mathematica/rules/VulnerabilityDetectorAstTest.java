package org.sonar.plugins.mathematica.rules;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.MethodSource;
import org.sonar.api.batch.fs.InputFile;
import org.sonar.api.batch.fs.TextRange;
import org.sonar.api.batch.sensor.SensorContext;
import org.sonar.api.batch.sensor.issue.NewIssue;
import org.sonar.api.batch.sensor.issue.NewIssueLocation;
import org.sonar.api.rule.RuleKey;

import java.lang.reflect.Field;
import java.net.URI;
import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

class VulnerabilityDetectorAstTest {

    private VulnerabilityDetectorAst detector;
    private VulnerabilityDetectorAst detectorWithSensor;
    private InputFile inputFile;
    private SensorContext sensorContext;

    static Stream<String> provideContentSamples() {
        return Stream.of(
            "",
            "x = 1 + 2",
            "(* This is a comment *)\nx = 1 + 2",
            "x = 1 + 2;\ny = 3 + 4;\nz = x * y"
        );
    }

    @BeforeEach
    void setUp() throws Exception {
        detector = new VulnerabilityDetectorAst();
        detectorWithSensor = new VulnerabilityDetectorAst();

        // Setup mock sensor context
        sensorContext = mock(SensorContext.class);
        NewIssue newIssue = mock(NewIssue.class);
        NewIssueLocation newIssueLocation = mock(NewIssueLocation.class);

        when(sensorContext.newIssue()).thenReturn(newIssue);
        when(newIssue.forRule(any(RuleKey.class))).thenReturn(newIssue);
        when(newIssue.at(any(NewIssueLocation.class))).thenReturn(newIssue);
        when(newIssue.newLocation()).thenReturn(newIssueLocation);
        when(newIssueLocation.on(any(InputFile.class))).thenReturn(newIssueLocation);
        when(newIssueLocation.at(any(TextRange.class))).thenReturn(newIssueLocation);
        when(newIssueLocation.message(anyString())).thenReturn(newIssueLocation);

        // Mock MathematicaRulesSensor (the actual type of the sensor field)
        MathematicaRulesSensor rulesSensor = mock(MathematicaRulesSensor.class);

        // Initialize sensor field via reflection
        Field sensorField = BaseDetector.class.getDeclaredField("sensor");
        sensorField.setAccessible(true);
        sensorField.set(detectorWithSensor, rulesSensor);

        inputFile = mock(InputFile.class);
        when(inputFile.filename()).thenReturn("test.m");
        when(inputFile.uri()).thenReturn(URI.create("file:///test.m"));

        TextRange textRange = mock(TextRange.class);
        when(inputFile.selectLine(anyInt())).thenReturn(textRange);
    }

    @ParameterizedTest
    @MethodSource("provideContentSamples")
    void testDetectAllVulnerabilitiesVariousContent(String content) {
        // Should complete without errors
        assertDoesNotThrow(() -> detector.detectAllVulnerabilities(inputFile, content));
    }

    @Test
    void testDetectAllVulnerabilitiesLargeFileUnderLimit() {
        // Create content with 1000 lines (under the 50K limit)
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 1000; i++) {
            sb.append("x").append(i).append(" = ").append(i).append(";\n");
        }
        String content = sb.toString();

        // Should process the file without errors
        assertDoesNotThrow(() -> detector.detectAllVulnerabilities(inputFile, content));
    }

    @Test
    void testDetectAllVulnerabilitiesLargeFileOverLimit() {
        // Create content with 60K lines (over the 50K limit)
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 60000; i++) {
            sb.append("x").append(i).append(" = ").append(i).append(";\n");
        }
        String content = sb.toString();

        // Should skip the file but complete without errors
        assertDoesNotThrow(() -> detector.detectAllVulnerabilities(inputFile, content));
    }

    @Test
    void testDetectAllVulnerabilitiesWithException() {
        // Use null sensor to trigger exception path
        VulnerabilityDetectorAst detectorWithNullSensor = new VulnerabilityDetectorAst();
        String content = "x = 1 + 2";

        // This should handle the exception gracefully
        assertDoesNotThrow(() -> detectorWithNullSensor.detectAllVulnerabilities(inputFile, content));
    }

    @Test
    void testDetectAllVulnerabilitiesMultipleCallsCachesAst() {
        String content = "x = 1 + 2";

        // Call multiple times with same content - should complete without errors
        assertDoesNotThrow(() -> detector.detectAllVulnerabilities(inputFile, content));
        assertDoesNotThrow(() -> detector.detectAllVulnerabilities(inputFile, content));
    }

    static Stream<String> provideEmptyOrInvalidAstContent() {
        return Stream.of(
            "[[[[invalid syntax",
            "",
            "(* This is just a comment *)"
        );
    }

    @ParameterizedTest
    @MethodSource("provideEmptyOrInvalidAstContent")
    void testDetectAllVulnerabilitiesWithEmptyOrInvalidAst(String content) {
        // Should handle gracefully regardless of whether AST is null/empty
        assertDoesNotThrow(() -> detector.detectAllVulnerabilities(inputFile, content));
    }

    @Test
    void testDetectAllVulnerabilitiesWithVulnerabilities() {
        // Test with actual vulnerability patterns to ensure visitor is invoked
        String content = "password = \"hardcoded123\";\n"
                        + "Run[\"rm -rf \" <> userInput];\n"
                        + "ToExpression[userInput];";

        // Should detect vulnerabilities without errors
        assertDoesNotThrow(() -> detector.detectAllVulnerabilities(inputFile, content));
    }

    @ParameterizedTest
    @MethodSource("provideValidContentForSensor")
    void testDetectAllVulnerabilitiesWithSensor(String content) {
        assertDoesNotThrow(() -> detectorWithSensor.detectAllVulnerabilities(inputFile, content));
    }

    private static Stream<String> provideValidContentForSensor() {
        return Stream.of(
            "Module[{x}, x = 5; Print[x]]",
            "f[x_] := x^2;\nresult = f[5];\nPrint[result];",
            "x = Sin[0.5];\ny = Cos[x];"
        );
    }

    @Test
    void testDetectAllVulnerabilitiesExceptionDuringVisit() {
        // Test exception handling when InputFile throws during processing
        InputFile problematicFile = mock(InputFile.class);
        when(problematicFile.filename()).thenReturn("problematic.m");
        when(problematicFile.uri()).thenThrow(new RuntimeException("Test exception"));

        String content = "x = 1 + 2";

        // Should catch exception and complete gracefully (covers lines 65-68)
        assertDoesNotThrow(() -> detectorWithSensor.detectAllVulnerabilities(problematicFile, content));
    }
}
