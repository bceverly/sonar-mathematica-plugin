package org.sonar.plugins.mathematica.rules;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;
import org.sonar.api.batch.fs.InputFile;
import org.sonar.api.batch.fs.TextRange;
import org.sonar.api.batch.sensor.SensorContext;
import org.sonar.api.batch.sensor.issue.NewIssue;
import org.sonar.api.batch.sensor.issue.NewIssueLocation;
import org.sonar.api.rule.RuleKey;

import java.util.stream.Stream;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.Mockito.atLeastOnce;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.mockito.Mockito.RETURNS_DEEP_STUBS;

class VulnerabilityDetectorTest {

    private VulnerabilityDetector detector;
    private SensorContext context;
    private InputFile inputFile;
    private NewIssue newIssue;
    private NewIssueLocation location;
    private TextRange textRange;

    @BeforeEach
    void setUp() {
        detector = new VulnerabilityDetector();
        context = mock(SensorContext.class, RETURNS_DEEP_STUBS);
        inputFile = mock(InputFile.class);
        newIssue = mock(NewIssue.class, RETURNS_DEEP_STUBS);
        location = mock(NewIssueLocation.class, RETURNS_DEEP_STUBS);
        textRange = mock(TextRange.class);

        when(inputFile.filename()).thenReturn("sample.m");
        when(inputFile.uri()).thenReturn(java.net.URI.create("file:///Users/dev/sample.m"));
        when(inputFile.selectLine(anyInt())).thenReturn(textRange);
        when(context.newIssue()).thenReturn(newIssue);
        when(newIssue.forRule(any(RuleKey.class))).thenReturn(newIssue);
        when(newIssue.at(any(NewIssueLocation.class))).thenReturn(newIssue);
        when(newIssue.newLocation()).thenReturn(location);
        when(location.on(any(InputFile.class))).thenReturn(location);
        when(location.at(any(TextRange.class))).thenReturn(location);
        when(location.message(any(String.class))).thenReturn(location);
    }

    // ===== PARAMETERIZED TESTS FOR BETTER MAINTAINABILITY =====

    private static Stream<Arguments> hardcodedCredentialsTestData() {
        return Stream.of(
            Arguments.of("password = \"mySecretPassword123\";", true),
            Arguments.of("apiKey = \"abcdefgh12345678\";\nsecret = \"secretValue1234\";", true),
            Arguments.of("password = \"example_password\";", false), // Placeholder
            Arguments.of("password = \"xxxxxxxxxxxxx\";", false), // Placeholder
            Arguments.of("password = \"password\";", false), // Placeholder
            Arguments.of("secret = \"secret\";", false), // Placeholder
            Arguments.of("password = \"**********\";", false), // Asterisks
            Arguments.of("apiKey = \"your_api_key_here\";", false) // your_ placeholder
        );
    }

    @ParameterizedTest
    @MethodSource("hardcodedCredentialsTestData")
    void testDetectHardcodedCredentials(String content, boolean shouldDetect) {
        detector.detectHardcodedCredentials(context, inputFile, content);
        if (shouldDetect) {
            verify(context, atLeastOnce()).newIssue();
        } else {
            verify(context, never()).newIssue();
        }
    }

    @Test
    void testDetectHardcodedCredentialsSkipsBuildFiles() {
        // Build/documentation files should be skipped to avoid false positives
        InputFile buildFile = mock(InputFile.class);
        when(buildFile.filename()).thenReturn("Notebooks.wl");
        when(buildFile.uri()).thenReturn(java.net.URI.create("file:///DocumentationBuild/Kernel/Build/Notebooks.wl"));

        String content = "password = \"realPasswordHere123\";";

        detector.detectHardcodedCredentials(context, buildFile, content);
        verify(context, never()).newIssue();
    }

    private static Stream<Arguments> commandInjectionTestData() {
        return Stream.of(
            Arguments.of("Run[\"rm -rf \" <> userInput];", true),
            Arguments.of("RunProcess[{\"sh\" <> cmd}];", true),
            Arguments.of("Import[{\"bash\" <> script}];", true)
        );
    }

    @ParameterizedTest
    @MethodSource("commandInjectionTestData")
    void testDetectCommandInjection(String content, boolean shouldDetect) {
        detector.detectCommandInjection(context, inputFile, content);
        verify(context, atLeastOnce()).newIssue();
    }

    private static Stream<Arguments> sqlInjectionTestData() {
        return Stream.of(
            Arguments.of("SQLExecute[conn, \"SELECT * FROM users WHERE name='\" <> userName <> \"'\"];", true),
            Arguments.of("SQLSelect[conn, \"table WHERE id=\" <> userId];", true),
            Arguments.of("SQLUpdate[conn, \"UPDATE users SET name=\" <> newName];", true)
        );
    }

    @ParameterizedTest
    @MethodSource("sqlInjectionTestData")
    void testDetectSqlInjection(String content, boolean shouldDetect) {
        detector.detectSqlInjection(context, inputFile, content);
        verify(context, atLeastOnce()).newIssue();
    }

                private static Stream<Arguments> weakCryptographyTestData() {
        return Stream.of(
            Arguments.of("Hash[data, \"MD5\"];", true),
            Arguments.of("Hash[password, \"SHA1\"];", true),
            Arguments.of("token = Random[];", true)
        );
    }

    @ParameterizedTest
    @MethodSource("weakCryptographyTestData")
    void testDetectWeakCryptography(String content, boolean shouldDetect) {
        detector.detectWeakCryptography(context, inputFile, content);
        verify(context, atLeastOnce()).newIssue();
    }

    private static Stream<Arguments> insecureDeserializationTestData() {
        return Stream.of(
            Arguments.of("Import[untrusted, \"MX\"];", true),
            Arguments.of("Import[file, \"WDX\"];", true)
        );
    }

    @ParameterizedTest
    @MethodSource("insecureDeserializationTestData")
    void testDetectInsecureDeserialization(String content, boolean shouldDetect) {
        detector.detectInsecureDeserialization(context, inputFile, content);
        verify(context, atLeastOnce()).newIssue();
    }

                private static Stream<Arguments> insecureRandomTestData() {
        return Stream.of(
            Arguments.of("token = Random[];", true),
            Arguments.of("password = RandomChoice[chars];", true),
            Arguments.of("key = Random[];", true),
            Arguments.of("sessionId = RandomChoice[ids];", true),
            Arguments.of("x = Random[];", false) // Non-security context
        );
    }

    @ParameterizedTest
    @MethodSource("insecureRandomTestData")
    void testDetectInsecureRandomExpanded(String content, boolean shouldDetect) {
        detector.detectInsecureRandomExpanded(context, inputFile, content);
        if (shouldDetect) {
            verify(context, atLeastOnce()).newIssue();
        } else {
            verify(context, never()).newIssue();
        }
    }

                private static Stream<Arguments> toExpressionOnInputTestData() {
        return Stream.of(
            Arguments.of("data = Import[\"file.txt\"];\nresult = ToExpression[data];", true),
            Arguments.of("response = URLFetch[url];\nToExpression[response];", true),
            Arguments.of("APIFunction[{\"expr\" -> \"String\"}, ToExpression[expr]];", true),
            Arguments.of("FormFunction[{}, ToExpression[userInput]];", true),
            Arguments.of("ToExpression[inputData];", true),
            Arguments.of("ToExpression[userData];", true),
            Arguments.of("ToExpression[requestData];", true)
        );
    }

    @ParameterizedTest
    @MethodSource("toExpressionOnInputTestData")
    void testDetectToExpressionOnInput(String content, boolean shouldDetect) {
        detector.detectToExpressionOnInput(context, inputFile, content);
        verify(context, atLeastOnce()).newIssue();
    }

    private static Stream<Arguments> unsanitizedRunProcessTestData() {
        return Stream.of(
            Arguments.of("cmd = Import[\"cmd.txt\"];\nRunProcess[cmd];", true),
            Arguments.of("script = URLFetch[url];\nRun[script];", true),
            Arguments.of("APIFunction[{}, RunProcess[input]];", true),
            Arguments.of("FormFunction[{}, Run[userCmd]];", true),
            Arguments.of("RunProcess[userCommand];", true),
            Arguments.of("Run[inputCmd];", true)
        );
    }

    @ParameterizedTest
    @MethodSource("unsanitizedRunProcessTestData")
    void testDetectUnsanitizedRunProcess(String content, boolean shouldDetect) {
        detector.detectUnsanitizedRunProcess(context, inputFile, content);
        verify(context, atLeastOnce()).newIssue();
    }

                private static Stream<Arguments> hardcodedApiKeysTestData() {
        return Stream.of(
            Arguments.of("\"APIKey\" -> \"abcdefghijklmnopqrstuvwxyz123456\";", true),
            Arguments.of("\"token\" -> \"sk_test_1234567890abcdefghijk\";", true),
            Arguments.of("\"secret\" -> \"my_secret_key_1234567890\";", true),
            Arguments.of("\"APIKey\" -> SystemCredential[\"key\"];", false) // Not hardcoded
        );
    }

    @ParameterizedTest
    @MethodSource("hardcodedApiKeysTestData")
    void testDetectHardcodedApiKeys(String content, boolean shouldDetect) {
        detector.detectHardcodedApiKeys(context, inputFile, content);
        if (shouldDetect) {
            verify(context, atLeastOnce()).newIssue();
        } else {
            verify(context, never()).newIssue();
        }
    }

    private static Stream<Arguments> needsGetUntrustedTestData() {
        return Stream.of(
            Arguments.of("pkg = Import[\"pkg.txt\"];\nNeeds[pkg];", true),
            Arguments.of("path = URLFetch[url];\nGet[path];", true),
            Arguments.of("Needs[inputPackage];", true),
            Arguments.of("Get[userPath];", true),
            Arguments.of("Needs[packagePath];", true)
        );
    }

    @ParameterizedTest
    @MethodSource("needsGetUntrustedTestData")
    void testDetectNeedsGetUntrusted(String content, boolean shouldDetect) {
        detector.detectNeedsGetUntrusted(context, inputFile, content);
        verify(context, atLeastOnce()).newIssue();
    }

    private static Stream<Arguments> exposingSensitiveDataTestData() {
        return Stream.of(
            Arguments.of("CloudDeploy[APIFunction[{}, $UserName]];", true),
            Arguments.of("CloudDeploy[FormFunction[{}, $MachineName]];", true),
            Arguments.of("CloudDeploy[APIFunction[{}, $HomeDirectory]];", true),
            Arguments.of("CloudDeploy[APIFunction[{}, $InstallationDirectory]];", true),
            Arguments.of("CloudDeploy[APIFunction[{}, SystemCredential[\"key\"]]];", true),
            Arguments.of("CloudDeploy[APIFunction[{}, password]];", true),
            Arguments.of("CloudDeploy[APIFunction[{}, $ProcessID]];", true)
        );
    }

    @ParameterizedTest
    @MethodSource("exposingSensitiveDataTestData")
    void testDetectExposingSensitiveData(String content, boolean shouldDetect) {
        detector.detectExposingSensitiveData(context, inputFile, content);
        verify(context, atLeastOnce()).newIssue();
    }

    private static Stream<Arguments> formFunctionValidationTestData() {
        return Stream.of(
            Arguments.of("FormFunction[{\"name\" -> \"String\", \"value\" -> \"String\"}];", true, true),
            Arguments.of("FormFunction[{\"name\" -> Restricted[\"String\"]}];", false, false),
            Arguments.of("FormFunction[{\"value\" -> Interpreter[\"Number\"]}];", false, false),
            Arguments.of("FormFunction[{\"count\" -> _Integer}];", false, false),
            Arguments.of("FormFunction[{\"value\" -> _Real}];", false, false),
            Arguments.of("FormFunction[{\"text\" -> _String}];", false, false)
        );
    }

    @ParameterizedTest
    @MethodSource("formFunctionValidationTestData")
    void testDetectMissingFormFunctionValidation(String content, boolean shouldDetect, boolean expectIssue) {
        detector.detectMissingFormFunctionValidation(context, inputFile, content);
        if (expectIssue) {
            verify(context, atLeastOnce()).newIssue();
        } else {
            verify(context, never()).newIssue();
        }
    }

            private static Stream<Arguments> missingSanitizationTestData() {
        return Stream.of(
            Arguments.of("DeleteFile[filePath];", true),
            Arguments.of("DeleteDirectory[dirPath];", true),
            Arguments.of("RenameFile[oldPath, newPath];", true),
            Arguments.of("SystemOpen[filePath];", true)
        );
    }

    @ParameterizedTest
    @MethodSource("missingSanitizationTestData")
    void testDetectMissingSanitization(String content, boolean shouldDetect) {
        detector.detectMissingSanitization(context, inputFile, content);
        verify(context, atLeastOnce()).newIssue();
    }

        // ===== COMPREHENSIVE TESTS =====

            @Test
    void testLargeFileSkipping() {
        // Create very long content to test file size limiting
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 60000; i++) {
            sb.append("line ").append(i).append(";\n");
        }
        String content = sb.toString();

        assertDoesNotThrow(() -> {
            detector.detectHardcodedCredentials(context, inputFile, content);
            detector.detectCommandInjection(context, inputFile, content);
        });
    }

    // ===== ADDITIONAL EDGE CASE TESTS FOR 80%+ COVERAGE =====

        @Test
    void testDetectSqlInjectionDelete() {
        String content = "SQLExecute[conn, \"DELETE FROM users WHERE id=\" <> userId];";
        detector.detectSqlInjection(context, inputFile, content);
        verify(context, atLeastOnce()).newIssue();
    }

                    @Test
    void testDetectInsecureRandomToken() {
        String content = "token = RandomChoice[chars];";
        detector.detectInsecureRandomExpanded(context, inputFile, content);
        verify(context, atLeastOnce()).newIssue();
    }

        @Test
    void testDetectHardcodedApiKeysBearer() {
        String content = "\"Authorization\" -> \"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9\";";
        assertDoesNotThrow(() -> detector.detectHardcodedApiKeys(context, inputFile, content));
    }


    // ===== PARAMETERIZED TESTS =====

    @ParameterizedTest
    @MethodSource("detectCodeInjectionTestData")
    void testDetectDetectCodeInjection(String content) {
        assertDoesNotThrow(() ->
            detector.detectCodeInjection(context, inputFile, content)
        );
    }

    private static Stream<Arguments> detectCodeInjectionTestData() {
        return Stream.of(
            Arguments.of("ToExpression[userInput];"),
            Arguments.of("Evaluate[expr];"),
            Arguments.of("result = Symbol[userInput];")
        );
    }

    @ParameterizedTest
    @MethodSource("detectCommandInjectionTestData")
    void testDetectDetectCommandInjection(String content) {
        assertDoesNotThrow(() ->
            detector.detectCommandInjection(context, inputFile, content)
        );
    }

    private static Stream<Arguments> detectCommandInjectionTestData() {
        return Stream.of(
            Arguments.of("RunProcess[{\\\"bash\\\", \\\"-c\\\", userCommand}];"),
            Arguments.of("Run[\\\"sh\\\" <> userScript];")
        );
    }

    @ParameterizedTest
    @MethodSource("detectDynamicInjectionTestData")
    void testDetectDetectDynamicInjection(String content) {
        assertDoesNotThrow(() ->
            detector.detectDynamicInjection(context, inputFile, content)
        );
    }

    private static Stream<Arguments> detectDynamicInjectionTestData() {
        return Stream.of(
            Arguments.of("Dynamic[x = ToExpression[input]];"),
            Arguments.of("Dynamic[result = ToExpression[data]];")
        );
    }

    @ParameterizedTest
    @MethodSource("detectExposingSensitiveDataTestData")
    void testDetectDetectExposingSensitiveData(String content) {
        assertDoesNotThrow(() ->
            detector.detectExposingSensitiveData(context, inputFile, content)
        );
    }

    private static Stream<Arguments> detectExposingSensitiveDataTestData() {
        return Stream.of(
            Arguments.of("CloudDeploy[APIFunction[{}, $ProcessID]];"),
            Arguments.of("CloudDeploy[APIFunction[{}, $HomeDirectory]];"),
            Arguments.of("CloudDeploy[APIFunction[{}, $InstallationDirectory]];"),
            Arguments.of("CloudDeploy[APIFunction[{}, SystemCredential[\\\"apiKey\\\"]]];"),
            Arguments.of("CloudDeploy[APIFunction[{}, password]];")
        );
    }

    @ParameterizedTest
    @MethodSource("detectHardcodedCredentialsTestData")
    void testDetectDetectHardcodedCredentials(String content) {
        assertDoesNotThrow(() ->
            detector.detectHardcodedCredentials(context, inputFile, content)
        );
    }

    private static Stream<Arguments> detectHardcodedCredentialsTestData() {
        return Stream.of(
            Arguments.of(""),
            Arguments.of("password = \\\"hardcoded123\\"),
            Arguments.of("auth = \\\"Bearer sk_live_abc123def456\\")
        );
    }

    @ParameterizedTest
    @MethodSource("detectInsecureDeserializationTestData")
    void testDetectDetectInsecureDeserialization(String content) {
        assertDoesNotThrow(() ->
            detector.detectInsecureDeserialization(context, inputFile, content)
        );
    }

    private static Stream<Arguments> detectInsecureDeserializationTestData() {
        return Stream.of(
            Arguments.of("Get[untrustedFile];"),
            Arguments.of("data = Import[untrustedFile, \\\"WDX\\\"];"),
            Arguments.of("data = Get[untrusted];")
        );
    }

    @ParameterizedTest
    @MethodSource("detectMissingCloudAuthTestData")
    void testDetectDetectMissingCloudAuth(String content) {
        assertDoesNotThrow(() ->
            detector.detectMissingCloudAuth(context, inputFile, content)
        );
    }

    private static Stream<Arguments> detectMissingCloudAuthTestData() {
        return Stream.of(
            Arguments.of("CloudDeploy[APIFunction[{}, expr]];"),
            Arguments.of("CloudDeploy[FormFunction[{}, body]];"),
            Arguments.of("CloudDeploy[APIFunction[{}, expr], Permissions->\\\"Private\\\"];")
        );
    }

    @ParameterizedTest
    @MethodSource("detectMissingFormFunctionValidationTestData")
    void testDetectDetectMissingFormFunctionValidation(String content) {
        assertDoesNotThrow(() ->
            detector.detectMissingFormFunctionValidation(context, inputFile, content)
        );
    }

    private static Stream<Arguments> detectMissingFormFunctionValidationTestData() {
        return Stream.of(
            Arguments.of("FormFunction[{\\\"name\\\" -> \\\"String\\\", \\\"email\\\" -> \\\"String\\\", \\\"age\\\" -> \\\"String\\\"}];"),
            Arguments.of("FormFunction[{\\\"age\\\" -> Restricted[\\\"Integer\\\"]}];"),
            Arguments.of("FormFunction[{\\\"count\\\" -> Interpreter[\\\"Number\\\"]}];"),
            Arguments.of("FormFunction[{\\\"value\\\" -> _Real}];")
        );
    }

    @ParameterizedTest
    @MethodSource("detectMissingSanitizationTestData")
    void testDetectDetectMissingSanitization(String content) {
        assertDoesNotThrow(() ->
            detector.detectMissingSanitization(context, inputFile, content)
        );
    }

    private static Stream<Arguments> detectMissingSanitizationTestData() {
        return Stream.of(
            Arguments.of("RenameDirectory[oldPath, newPath];"),
            Arguments.of("SystemOpen[userPath];")
        );
    }

    @ParameterizedTest
    @MethodSource("detectNeedsGetUntrustedTestData")
    void testDetectDetectNeedsGetUntrusted(String content) {
        assertDoesNotThrow(() ->
            detector.detectNeedsGetUntrusted(context, inputFile, content)
        );
    }

    private static Stream<Arguments> detectNeedsGetUntrustedTestData() {
        return Stream.of(
            Arguments.of("Needs[packagePath];"),
            Arguments.of("pkg = Import[\\\"pkg.txt\\\"];\\nNeeds[pkg];")
        );
    }

    @ParameterizedTest
    @MethodSource("detectPathTraversalTestData")
    void testDetectDetectPathTraversal(String content) {
        assertDoesNotThrow(() ->
            detector.detectPathTraversal(context, inputFile, content)
        );
    }

    private static Stream<Arguments> detectPathTraversalTestData() {
        return Stream.of(
            Arguments.of("Import[basePath <> fileName];"),
            Arguments.of("DeleteFile[directory <> filename];")
        );
    }

    @ParameterizedTest
    @MethodSource("detectSsrfTestData")
    void testDetectDetectSsrf(String content) {
        assertDoesNotThrow(() ->
            detector.detectSsrf(context, inputFile, content)
        );
    }

    private static Stream<Arguments> detectSsrfTestData() {
        return Stream.of(
            Arguments.of("URLFetch[\\\"http://\\\" <> host];"),
            Arguments.of("Import[\\\"http://\\\" <> server];"),
            Arguments.of("URLRead[\\\"http://\\\" <> targetServer];")
        );
    }

    @ParameterizedTest
    @MethodSource("detectToExpressionOnInputTestData")
    void testDetectDetectToExpressionOnInput(String content) {
        assertDoesNotThrow(() ->
            detector.detectToExpressionOnInput(context, inputFile, content)
        );
    }

    private static Stream<Arguments> detectToExpressionOnInputTestData() {
        return Stream.of(
            Arguments.of("result = ToExpression[requestData];"),
            Arguments.of("imported = Import[\\\"file.txt\\\"];\\nresult = ToExpression[imported];")
        );
    }

    @ParameterizedTest
    @MethodSource("detectUnsafeCloudDeployTestData")
    void testDetectDetectUnsafeCloudDeploy(String content) {
        assertDoesNotThrow(() ->
            detector.detectUnsafeCloudDeploy(context, inputFile, content)
        );
    }

    private static Stream<Arguments> detectUnsafeCloudDeployTestData() {
        return Stream.of(
            Arguments.of("CloudDeploy[myFunction];"),
            Arguments.of("CloudDeploy[myFunction, Permissions->\\\"Private\\\"];")
        );
    }

    @ParameterizedTest
    @MethodSource("detectUnsafeSymbolTestData")
    void testDetectDetectUnsafeSymbol(String content) {
        assertDoesNotThrow(() ->
            detector.detectUnsafeSymbol(context, inputFile, content)
        );
    }

    private static Stream<Arguments> detectUnsafeSymbolTestData() {
        return Stream.of(
            Arguments.of("Symbol[userInput];"),
            Arguments.of("sym = Symbol[inputString];")
        );
    }

    @ParameterizedTest
    @MethodSource("detectUnsanitizedRunProcessTestData")
    void testDetectDetectUnsanitizedRunProcess(String content) {
        assertDoesNotThrow(() ->
            detector.detectUnsanitizedRunProcess(context, inputFile, content)
        );
    }

    private static Stream<Arguments> detectUnsanitizedRunProcessTestData() {
        return Stream.of(
            Arguments.of("Run[inputCmd];"),
            Arguments.of("script = URLFetch[url];\\nRun[script];")
        );
    }

    @ParameterizedTest
    @MethodSource("detectWeakCryptographyTestData")
    void testDetectDetectWeakCryptography(String content) {
        assertDoesNotThrow(() ->
            detector.detectWeakCryptography(context, inputFile, content)
        );
    }

    private static Stream<Arguments> detectWeakCryptographyTestData() {
        return Stream.of(
            Arguments.of("sessionId = RandomInteger[];"),
            Arguments.of("hash = Hash[data, \\\"SHA1\\\"];")
        );
    }

    @ParameterizedTest
    @MethodSource("detectXXETestData")
    void testDetectDetectXXE(String content) {
        assertDoesNotThrow(() ->
            detector.detectXXE(context, inputFile, content)
        );
    }

    private static Stream<Arguments> detectXXETestData() {
        return Stream.of(
            Arguments.of("Import[xmlFile, \\\"XML\\\"];"),
            Arguments.of("Import[xmlFile, \\\"XML\\\", ProcessDTD->False];"),
            Arguments.of("data = Import[externalXml, \\\"XML\\\"];")
        );
    }

}
